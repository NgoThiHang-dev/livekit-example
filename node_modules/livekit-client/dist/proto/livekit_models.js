"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RTPStats_GapHistogramEntry = exports.RTPStats = exports.VideoConfiguration = exports.ClientConfiguration = exports.ClientInfo = exports.ParticipantTracks = exports.UserPacket = exports.SpeakerInfo = exports.ActiveSpeakerUpdate = exports.DataPacket = exports.VideoLayer = exports.TrackInfo = exports.ParticipantInfo = exports.ParticipantPermission = exports.Codec = exports.Room = exports.clientInfo_SDKToJSON = exports.clientInfo_SDKFromJSON = exports.ClientInfo_SDK = exports.dataPacket_KindToJSON = exports.dataPacket_KindFromJSON = exports.DataPacket_Kind = exports.participantInfo_StateToJSON = exports.participantInfo_StateFromJSON = exports.ParticipantInfo_State = exports.clientConfigSettingToJSON = exports.clientConfigSettingFromJSON = exports.ClientConfigSetting = exports.connectionQualityToJSON = exports.connectionQualityFromJSON = exports.ConnectionQuality = exports.videoQualityToJSON = exports.videoQualityFromJSON = exports.VideoQuality = exports.trackSourceToJSON = exports.trackSourceFromJSON = exports.TrackSource = exports.trackTypeToJSON = exports.trackTypeFromJSON = exports.TrackType = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const timestamp_1 = require("./google/protobuf/timestamp");
exports.protobufPackage = "livekit";
var TrackType;
(function (TrackType) {
    TrackType[TrackType["AUDIO"] = 0] = "AUDIO";
    TrackType[TrackType["VIDEO"] = 1] = "VIDEO";
    TrackType[TrackType["DATA"] = 2] = "DATA";
    TrackType[TrackType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TrackType = exports.TrackType || (exports.TrackType = {}));
function trackTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "AUDIO":
            return TrackType.AUDIO;
        case 1:
        case "VIDEO":
            return TrackType.VIDEO;
        case 2:
        case "DATA":
            return TrackType.DATA;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TrackType.UNRECOGNIZED;
    }
}
exports.trackTypeFromJSON = trackTypeFromJSON;
function trackTypeToJSON(object) {
    switch (object) {
        case TrackType.AUDIO:
            return "AUDIO";
        case TrackType.VIDEO:
            return "VIDEO";
        case TrackType.DATA:
            return "DATA";
        default:
            return "UNKNOWN";
    }
}
exports.trackTypeToJSON = trackTypeToJSON;
var TrackSource;
(function (TrackSource) {
    TrackSource[TrackSource["UNKNOWN"] = 0] = "UNKNOWN";
    TrackSource[TrackSource["CAMERA"] = 1] = "CAMERA";
    TrackSource[TrackSource["MICROPHONE"] = 2] = "MICROPHONE";
    TrackSource[TrackSource["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
    TrackSource[TrackSource["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
    TrackSource[TrackSource["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TrackSource = exports.TrackSource || (exports.TrackSource = {}));
function trackSourceFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return TrackSource.UNKNOWN;
        case 1:
        case "CAMERA":
            return TrackSource.CAMERA;
        case 2:
        case "MICROPHONE":
            return TrackSource.MICROPHONE;
        case 3:
        case "SCREEN_SHARE":
            return TrackSource.SCREEN_SHARE;
        case 4:
        case "SCREEN_SHARE_AUDIO":
            return TrackSource.SCREEN_SHARE_AUDIO;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TrackSource.UNRECOGNIZED;
    }
}
exports.trackSourceFromJSON = trackSourceFromJSON;
function trackSourceToJSON(object) {
    switch (object) {
        case TrackSource.UNKNOWN:
            return "UNKNOWN";
        case TrackSource.CAMERA:
            return "CAMERA";
        case TrackSource.MICROPHONE:
            return "MICROPHONE";
        case TrackSource.SCREEN_SHARE:
            return "SCREEN_SHARE";
        case TrackSource.SCREEN_SHARE_AUDIO:
            return "SCREEN_SHARE_AUDIO";
        default:
            return "UNKNOWN";
    }
}
exports.trackSourceToJSON = trackSourceToJSON;
var VideoQuality;
(function (VideoQuality) {
    VideoQuality[VideoQuality["LOW"] = 0] = "LOW";
    VideoQuality[VideoQuality["MEDIUM"] = 1] = "MEDIUM";
    VideoQuality[VideoQuality["HIGH"] = 2] = "HIGH";
    VideoQuality[VideoQuality["OFF"] = 3] = "OFF";
    VideoQuality[VideoQuality["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VideoQuality = exports.VideoQuality || (exports.VideoQuality = {}));
function videoQualityFromJSON(object) {
    switch (object) {
        case 0:
        case "LOW":
            return VideoQuality.LOW;
        case 1:
        case "MEDIUM":
            return VideoQuality.MEDIUM;
        case 2:
        case "HIGH":
            return VideoQuality.HIGH;
        case 3:
        case "OFF":
            return VideoQuality.OFF;
        case -1:
        case "UNRECOGNIZED":
        default:
            return VideoQuality.UNRECOGNIZED;
    }
}
exports.videoQualityFromJSON = videoQualityFromJSON;
function videoQualityToJSON(object) {
    switch (object) {
        case VideoQuality.LOW:
            return "LOW";
        case VideoQuality.MEDIUM:
            return "MEDIUM";
        case VideoQuality.HIGH:
            return "HIGH";
        case VideoQuality.OFF:
            return "OFF";
        default:
            return "UNKNOWN";
    }
}
exports.videoQualityToJSON = videoQualityToJSON;
var ConnectionQuality;
(function (ConnectionQuality) {
    ConnectionQuality[ConnectionQuality["POOR"] = 0] = "POOR";
    ConnectionQuality[ConnectionQuality["GOOD"] = 1] = "GOOD";
    ConnectionQuality[ConnectionQuality["EXCELLENT"] = 2] = "EXCELLENT";
    ConnectionQuality[ConnectionQuality["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConnectionQuality = exports.ConnectionQuality || (exports.ConnectionQuality = {}));
function connectionQualityFromJSON(object) {
    switch (object) {
        case 0:
        case "POOR":
            return ConnectionQuality.POOR;
        case 1:
        case "GOOD":
            return ConnectionQuality.GOOD;
        case 2:
        case "EXCELLENT":
            return ConnectionQuality.EXCELLENT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ConnectionQuality.UNRECOGNIZED;
    }
}
exports.connectionQualityFromJSON = connectionQualityFromJSON;
function connectionQualityToJSON(object) {
    switch (object) {
        case ConnectionQuality.POOR:
            return "POOR";
        case ConnectionQuality.GOOD:
            return "GOOD";
        case ConnectionQuality.EXCELLENT:
            return "EXCELLENT";
        default:
            return "UNKNOWN";
    }
}
exports.connectionQualityToJSON = connectionQualityToJSON;
var ClientConfigSetting;
(function (ClientConfigSetting) {
    ClientConfigSetting[ClientConfigSetting["UNSET"] = 0] = "UNSET";
    ClientConfigSetting[ClientConfigSetting["DISABLED"] = 1] = "DISABLED";
    ClientConfigSetting[ClientConfigSetting["ENABLED"] = 2] = "ENABLED";
    ClientConfigSetting[ClientConfigSetting["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientConfigSetting = exports.ClientConfigSetting || (exports.ClientConfigSetting = {}));
function clientConfigSettingFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSET":
            return ClientConfigSetting.UNSET;
        case 1:
        case "DISABLED":
            return ClientConfigSetting.DISABLED;
        case 2:
        case "ENABLED":
            return ClientConfigSetting.ENABLED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ClientConfigSetting.UNRECOGNIZED;
    }
}
exports.clientConfigSettingFromJSON = clientConfigSettingFromJSON;
function clientConfigSettingToJSON(object) {
    switch (object) {
        case ClientConfigSetting.UNSET:
            return "UNSET";
        case ClientConfigSetting.DISABLED:
            return "DISABLED";
        case ClientConfigSetting.ENABLED:
            return "ENABLED";
        default:
            return "UNKNOWN";
    }
}
exports.clientConfigSettingToJSON = clientConfigSettingToJSON;
var ParticipantInfo_State;
(function (ParticipantInfo_State) {
    /** JOINING - websocket' connected, but not offered yet */
    ParticipantInfo_State[ParticipantInfo_State["JOINING"] = 0] = "JOINING";
    /** JOINED - server received client offer */
    ParticipantInfo_State[ParticipantInfo_State["JOINED"] = 1] = "JOINED";
    /** ACTIVE - ICE connectivity established */
    ParticipantInfo_State[ParticipantInfo_State["ACTIVE"] = 2] = "ACTIVE";
    /** DISCONNECTED - WS disconnected */
    ParticipantInfo_State[ParticipantInfo_State["DISCONNECTED"] = 3] = "DISCONNECTED";
    ParticipantInfo_State[ParticipantInfo_State["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ParticipantInfo_State = exports.ParticipantInfo_State || (exports.ParticipantInfo_State = {}));
function participantInfo_StateFromJSON(object) {
    switch (object) {
        case 0:
        case "JOINING":
            return ParticipantInfo_State.JOINING;
        case 1:
        case "JOINED":
            return ParticipantInfo_State.JOINED;
        case 2:
        case "ACTIVE":
            return ParticipantInfo_State.ACTIVE;
        case 3:
        case "DISCONNECTED":
            return ParticipantInfo_State.DISCONNECTED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ParticipantInfo_State.UNRECOGNIZED;
    }
}
exports.participantInfo_StateFromJSON = participantInfo_StateFromJSON;
function participantInfo_StateToJSON(object) {
    switch (object) {
        case ParticipantInfo_State.JOINING:
            return "JOINING";
        case ParticipantInfo_State.JOINED:
            return "JOINED";
        case ParticipantInfo_State.ACTIVE:
            return "ACTIVE";
        case ParticipantInfo_State.DISCONNECTED:
            return "DISCONNECTED";
        default:
            return "UNKNOWN";
    }
}
exports.participantInfo_StateToJSON = participantInfo_StateToJSON;
var DataPacket_Kind;
(function (DataPacket_Kind) {
    DataPacket_Kind[DataPacket_Kind["RELIABLE"] = 0] = "RELIABLE";
    DataPacket_Kind[DataPacket_Kind["LOSSY"] = 1] = "LOSSY";
    DataPacket_Kind[DataPacket_Kind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DataPacket_Kind = exports.DataPacket_Kind || (exports.DataPacket_Kind = {}));
function dataPacket_KindFromJSON(object) {
    switch (object) {
        case 0:
        case "RELIABLE":
            return DataPacket_Kind.RELIABLE;
        case 1:
        case "LOSSY":
            return DataPacket_Kind.LOSSY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DataPacket_Kind.UNRECOGNIZED;
    }
}
exports.dataPacket_KindFromJSON = dataPacket_KindFromJSON;
function dataPacket_KindToJSON(object) {
    switch (object) {
        case DataPacket_Kind.RELIABLE:
            return "RELIABLE";
        case DataPacket_Kind.LOSSY:
            return "LOSSY";
        default:
            return "UNKNOWN";
    }
}
exports.dataPacket_KindToJSON = dataPacket_KindToJSON;
var ClientInfo_SDK;
(function (ClientInfo_SDK) {
    ClientInfo_SDK[ClientInfo_SDK["UNKNOWN"] = 0] = "UNKNOWN";
    ClientInfo_SDK[ClientInfo_SDK["JS"] = 1] = "JS";
    ClientInfo_SDK[ClientInfo_SDK["SWIFT"] = 2] = "SWIFT";
    ClientInfo_SDK[ClientInfo_SDK["ANDROID"] = 3] = "ANDROID";
    ClientInfo_SDK[ClientInfo_SDK["FLUTTER"] = 4] = "FLUTTER";
    ClientInfo_SDK[ClientInfo_SDK["GO"] = 5] = "GO";
    ClientInfo_SDK[ClientInfo_SDK["UNITY"] = 6] = "UNITY";
    ClientInfo_SDK[ClientInfo_SDK["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientInfo_SDK = exports.ClientInfo_SDK || (exports.ClientInfo_SDK = {}));
function clientInfo_SDKFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return ClientInfo_SDK.UNKNOWN;
        case 1:
        case "JS":
            return ClientInfo_SDK.JS;
        case 2:
        case "SWIFT":
            return ClientInfo_SDK.SWIFT;
        case 3:
        case "ANDROID":
            return ClientInfo_SDK.ANDROID;
        case 4:
        case "FLUTTER":
            return ClientInfo_SDK.FLUTTER;
        case 5:
        case "GO":
            return ClientInfo_SDK.GO;
        case 6:
        case "UNITY":
            return ClientInfo_SDK.UNITY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ClientInfo_SDK.UNRECOGNIZED;
    }
}
exports.clientInfo_SDKFromJSON = clientInfo_SDKFromJSON;
function clientInfo_SDKToJSON(object) {
    switch (object) {
        case ClientInfo_SDK.UNKNOWN:
            return "UNKNOWN";
        case ClientInfo_SDK.JS:
            return "JS";
        case ClientInfo_SDK.SWIFT:
            return "SWIFT";
        case ClientInfo_SDK.ANDROID:
            return "ANDROID";
        case ClientInfo_SDK.FLUTTER:
            return "FLUTTER";
        case ClientInfo_SDK.GO:
            return "GO";
        case ClientInfo_SDK.UNITY:
            return "UNITY";
        default:
            return "UNKNOWN";
    }
}
exports.clientInfo_SDKToJSON = clientInfo_SDKToJSON;
const baseRoom = {
    sid: "",
    name: "",
    emptyTimeout: 0,
    maxParticipants: 0,
    creationTime: 0,
    turnPassword: "",
    metadata: "",
    numParticipants: 0,
    activeRecording: false,
};
exports.Room = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.emptyTimeout !== 0) {
            writer.uint32(24).uint32(message.emptyTimeout);
        }
        if (message.maxParticipants !== 0) {
            writer.uint32(32).uint32(message.maxParticipants);
        }
        if (message.creationTime !== 0) {
            writer.uint32(40).int64(message.creationTime);
        }
        if (message.turnPassword !== "") {
            writer.uint32(50).string(message.turnPassword);
        }
        for (const v of message.enabledCodecs) {
            exports.Codec.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.metadata !== "") {
            writer.uint32(66).string(message.metadata);
        }
        if (message.numParticipants !== 0) {
            writer.uint32(72).uint32(message.numParticipants);
        }
        if (message.activeRecording === true) {
            writer.uint32(80).bool(message.activeRecording);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRoom);
        message.enabledCodecs = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sid = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.emptyTimeout = reader.uint32();
                    break;
                case 4:
                    message.maxParticipants = reader.uint32();
                    break;
                case 5:
                    message.creationTime = longToNumber(reader.int64());
                    break;
                case 6:
                    message.turnPassword = reader.string();
                    break;
                case 7:
                    message.enabledCodecs.push(exports.Codec.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.metadata = reader.string();
                    break;
                case 9:
                    message.numParticipants = reader.uint32();
                    break;
                case 10:
                    message.activeRecording = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRoom);
        message.enabledCodecs = [];
        if (object.sid !== undefined && object.sid !== null) {
            message.sid = String(object.sid);
        }
        else {
            message.sid = "";
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.emptyTimeout !== undefined && object.emptyTimeout !== null) {
            message.emptyTimeout = Number(object.emptyTimeout);
        }
        else {
            message.emptyTimeout = 0;
        }
        if (object.maxParticipants !== undefined &&
            object.maxParticipants !== null) {
            message.maxParticipants = Number(object.maxParticipants);
        }
        else {
            message.maxParticipants = 0;
        }
        if (object.creationTime !== undefined && object.creationTime !== null) {
            message.creationTime = Number(object.creationTime);
        }
        else {
            message.creationTime = 0;
        }
        if (object.turnPassword !== undefined && object.turnPassword !== null) {
            message.turnPassword = String(object.turnPassword);
        }
        else {
            message.turnPassword = "";
        }
        if (object.enabledCodecs !== undefined && object.enabledCodecs !== null) {
            for (const e of object.enabledCodecs) {
                message.enabledCodecs.push(exports.Codec.fromJSON(e));
            }
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = String(object.metadata);
        }
        else {
            message.metadata = "";
        }
        if (object.numParticipants !== undefined &&
            object.numParticipants !== null) {
            message.numParticipants = Number(object.numParticipants);
        }
        else {
            message.numParticipants = 0;
        }
        if (object.activeRecording !== undefined &&
            object.activeRecording !== null) {
            message.activeRecording = Boolean(object.activeRecording);
        }
        else {
            message.activeRecording = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sid !== undefined && (obj.sid = message.sid);
        message.name !== undefined && (obj.name = message.name);
        message.emptyTimeout !== undefined &&
            (obj.emptyTimeout = message.emptyTimeout);
        message.maxParticipants !== undefined &&
            (obj.maxParticipants = message.maxParticipants);
        message.creationTime !== undefined &&
            (obj.creationTime = message.creationTime);
        message.turnPassword !== undefined &&
            (obj.turnPassword = message.turnPassword);
        if (message.enabledCodecs) {
            obj.enabledCodecs = message.enabledCodecs.map((e) => e ? exports.Codec.toJSON(e) : undefined);
        }
        else {
            obj.enabledCodecs = [];
        }
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.numParticipants !== undefined &&
            (obj.numParticipants = message.numParticipants);
        message.activeRecording !== undefined &&
            (obj.activeRecording = message.activeRecording);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = Object.assign({}, baseRoom);
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        message.emptyTimeout = (_c = object.emptyTimeout) !== null && _c !== void 0 ? _c : 0;
        message.maxParticipants = (_d = object.maxParticipants) !== null && _d !== void 0 ? _d : 0;
        message.creationTime = (_e = object.creationTime) !== null && _e !== void 0 ? _e : 0;
        message.turnPassword = (_f = object.turnPassword) !== null && _f !== void 0 ? _f : "";
        message.enabledCodecs = [];
        if (object.enabledCodecs !== undefined && object.enabledCodecs !== null) {
            for (const e of object.enabledCodecs) {
                message.enabledCodecs.push(exports.Codec.fromPartial(e));
            }
        }
        message.metadata = (_g = object.metadata) !== null && _g !== void 0 ? _g : "";
        message.numParticipants = (_h = object.numParticipants) !== null && _h !== void 0 ? _h : 0;
        message.activeRecording = (_j = object.activeRecording) !== null && _j !== void 0 ? _j : false;
        return message;
    },
};
const baseCodec = { mime: "", fmtpLine: "" };
exports.Codec = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mime !== "") {
            writer.uint32(10).string(message.mime);
        }
        if (message.fmtpLine !== "") {
            writer.uint32(18).string(message.fmtpLine);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCodec);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mime = reader.string();
                    break;
                case 2:
                    message.fmtpLine = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseCodec);
        if (object.mime !== undefined && object.mime !== null) {
            message.mime = String(object.mime);
        }
        else {
            message.mime = "";
        }
        if (object.fmtpLine !== undefined && object.fmtpLine !== null) {
            message.fmtpLine = String(object.fmtpLine);
        }
        else {
            message.fmtpLine = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.mime !== undefined && (obj.mime = message.mime);
        message.fmtpLine !== undefined && (obj.fmtpLine = message.fmtpLine);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseCodec);
        message.mime = (_a = object.mime) !== null && _a !== void 0 ? _a : "";
        message.fmtpLine = (_b = object.fmtpLine) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
const baseParticipantPermission = {
    canSubscribe: false,
    canPublish: false,
    canPublishData: false,
    hidden: false,
    recorder: false,
};
exports.ParticipantPermission = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.canSubscribe === true) {
            writer.uint32(8).bool(message.canSubscribe);
        }
        if (message.canPublish === true) {
            writer.uint32(16).bool(message.canPublish);
        }
        if (message.canPublishData === true) {
            writer.uint32(24).bool(message.canPublishData);
        }
        if (message.hidden === true) {
            writer.uint32(56).bool(message.hidden);
        }
        if (message.recorder === true) {
            writer.uint32(64).bool(message.recorder);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParticipantPermission);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.canSubscribe = reader.bool();
                    break;
                case 2:
                    message.canPublish = reader.bool();
                    break;
                case 3:
                    message.canPublishData = reader.bool();
                    break;
                case 7:
                    message.hidden = reader.bool();
                    break;
                case 8:
                    message.recorder = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseParticipantPermission);
        if (object.canSubscribe !== undefined && object.canSubscribe !== null) {
            message.canSubscribe = Boolean(object.canSubscribe);
        }
        else {
            message.canSubscribe = false;
        }
        if (object.canPublish !== undefined && object.canPublish !== null) {
            message.canPublish = Boolean(object.canPublish);
        }
        else {
            message.canPublish = false;
        }
        if (object.canPublishData !== undefined && object.canPublishData !== null) {
            message.canPublishData = Boolean(object.canPublishData);
        }
        else {
            message.canPublishData = false;
        }
        if (object.hidden !== undefined && object.hidden !== null) {
            message.hidden = Boolean(object.hidden);
        }
        else {
            message.hidden = false;
        }
        if (object.recorder !== undefined && object.recorder !== null) {
            message.recorder = Boolean(object.recorder);
        }
        else {
            message.recorder = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.canSubscribe !== undefined &&
            (obj.canSubscribe = message.canSubscribe);
        message.canPublish !== undefined && (obj.canPublish = message.canPublish);
        message.canPublishData !== undefined &&
            (obj.canPublishData = message.canPublishData);
        message.hidden !== undefined && (obj.hidden = message.hidden);
        message.recorder !== undefined && (obj.recorder = message.recorder);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseParticipantPermission);
        message.canSubscribe = (_a = object.canSubscribe) !== null && _a !== void 0 ? _a : false;
        message.canPublish = (_b = object.canPublish) !== null && _b !== void 0 ? _b : false;
        message.canPublishData = (_c = object.canPublishData) !== null && _c !== void 0 ? _c : false;
        message.hidden = (_d = object.hidden) !== null && _d !== void 0 ? _d : false;
        message.recorder = (_e = object.recorder) !== null && _e !== void 0 ? _e : false;
        return message;
    },
};
const baseParticipantInfo = {
    sid: "",
    identity: "",
    state: 0,
    metadata: "",
    joinedAt: 0,
    name: "",
    version: 0,
};
exports.ParticipantInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        if (message.state !== 0) {
            writer.uint32(24).int32(message.state);
        }
        for (const v of message.tracks) {
            exports.TrackInfo.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.metadata !== "") {
            writer.uint32(42).string(message.metadata);
        }
        if (message.joinedAt !== 0) {
            writer.uint32(48).int64(message.joinedAt);
        }
        if (message.name !== "") {
            writer.uint32(74).string(message.name);
        }
        if (message.version !== 0) {
            writer.uint32(80).uint32(message.version);
        }
        if (message.permission !== undefined) {
            exports.ParticipantPermission.encode(message.permission, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParticipantInfo);
        message.tracks = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sid = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                case 4:
                    message.tracks.push(exports.TrackInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.metadata = reader.string();
                    break;
                case 6:
                    message.joinedAt = longToNumber(reader.int64());
                    break;
                case 9:
                    message.name = reader.string();
                    break;
                case 10:
                    message.version = reader.uint32();
                    break;
                case 11:
                    message.permission = exports.ParticipantPermission.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseParticipantInfo);
        message.tracks = [];
        if (object.sid !== undefined && object.sid !== null) {
            message.sid = String(object.sid);
        }
        else {
            message.sid = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = String(object.identity);
        }
        else {
            message.identity = "";
        }
        if (object.state !== undefined && object.state !== null) {
            message.state = participantInfo_StateFromJSON(object.state);
        }
        else {
            message.state = 0;
        }
        if (object.tracks !== undefined && object.tracks !== null) {
            for (const e of object.tracks) {
                message.tracks.push(exports.TrackInfo.fromJSON(e));
            }
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = String(object.metadata);
        }
        else {
            message.metadata = "";
        }
        if (object.joinedAt !== undefined && object.joinedAt !== null) {
            message.joinedAt = Number(object.joinedAt);
        }
        else {
            message.joinedAt = 0;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.version !== undefined && object.version !== null) {
            message.version = Number(object.version);
        }
        else {
            message.version = 0;
        }
        if (object.permission !== undefined && object.permission !== null) {
            message.permission = exports.ParticipantPermission.fromJSON(object.permission);
        }
        else {
            message.permission = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sid !== undefined && (obj.sid = message.sid);
        message.identity !== undefined && (obj.identity = message.identity);
        message.state !== undefined &&
            (obj.state = participantInfo_StateToJSON(message.state));
        if (message.tracks) {
            obj.tracks = message.tracks.map((e) => e ? exports.TrackInfo.toJSON(e) : undefined);
        }
        else {
            obj.tracks = [];
        }
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.joinedAt !== undefined && (obj.joinedAt = message.joinedAt);
        message.name !== undefined && (obj.name = message.name);
        message.version !== undefined && (obj.version = message.version);
        message.permission !== undefined &&
            (obj.permission = message.permission
                ? exports.ParticipantPermission.toJSON(message.permission)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = Object.assign({}, baseParticipantInfo);
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
        message.tracks = [];
        if (object.tracks !== undefined && object.tracks !== null) {
            for (const e of object.tracks) {
                message.tracks.push(exports.TrackInfo.fromPartial(e));
            }
        }
        message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : "";
        message.joinedAt = (_e = object.joinedAt) !== null && _e !== void 0 ? _e : 0;
        message.name = (_f = object.name) !== null && _f !== void 0 ? _f : "";
        message.version = (_g = object.version) !== null && _g !== void 0 ? _g : 0;
        if (object.permission !== undefined && object.permission !== null) {
            message.permission = exports.ParticipantPermission.fromPartial(object.permission);
        }
        else {
            message.permission = undefined;
        }
        return message;
    },
};
const baseTrackInfo = {
    sid: "",
    type: 0,
    name: "",
    muted: false,
    width: 0,
    height: 0,
    simulcast: false,
    disableDtx: false,
    source: 0,
    mimeType: "",
    mid: "",
};
exports.TrackInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.muted === true) {
            writer.uint32(32).bool(message.muted);
        }
        if (message.width !== 0) {
            writer.uint32(40).uint32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(48).uint32(message.height);
        }
        if (message.simulcast === true) {
            writer.uint32(56).bool(message.simulcast);
        }
        if (message.disableDtx === true) {
            writer.uint32(64).bool(message.disableDtx);
        }
        if (message.source !== 0) {
            writer.uint32(72).int32(message.source);
        }
        for (const v of message.layers) {
            exports.VideoLayer.encode(v, writer.uint32(82).fork()).ldelim();
        }
        if (message.mimeType !== "") {
            writer.uint32(90).string(message.mimeType);
        }
        if (message.mid !== "") {
            writer.uint32(98).string(message.mid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTrackInfo);
        message.layers = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sid = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.muted = reader.bool();
                    break;
                case 5:
                    message.width = reader.uint32();
                    break;
                case 6:
                    message.height = reader.uint32();
                    break;
                case 7:
                    message.simulcast = reader.bool();
                    break;
                case 8:
                    message.disableDtx = reader.bool();
                    break;
                case 9:
                    message.source = reader.int32();
                    break;
                case 10:
                    message.layers.push(exports.VideoLayer.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.mimeType = reader.string();
                    break;
                case 12:
                    message.mid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseTrackInfo);
        message.layers = [];
        if (object.sid !== undefined && object.sid !== null) {
            message.sid = String(object.sid);
        }
        else {
            message.sid = "";
        }
        if (object.type !== undefined && object.type !== null) {
            message.type = trackTypeFromJSON(object.type);
        }
        else {
            message.type = 0;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.muted !== undefined && object.muted !== null) {
            message.muted = Boolean(object.muted);
        }
        else {
            message.muted = false;
        }
        if (object.width !== undefined && object.width !== null) {
            message.width = Number(object.width);
        }
        else {
            message.width = 0;
        }
        if (object.height !== undefined && object.height !== null) {
            message.height = Number(object.height);
        }
        else {
            message.height = 0;
        }
        if (object.simulcast !== undefined && object.simulcast !== null) {
            message.simulcast = Boolean(object.simulcast);
        }
        else {
            message.simulcast = false;
        }
        if (object.disableDtx !== undefined && object.disableDtx !== null) {
            message.disableDtx = Boolean(object.disableDtx);
        }
        else {
            message.disableDtx = false;
        }
        if (object.source !== undefined && object.source !== null) {
            message.source = trackSourceFromJSON(object.source);
        }
        else {
            message.source = 0;
        }
        if (object.layers !== undefined && object.layers !== null) {
            for (const e of object.layers) {
                message.layers.push(exports.VideoLayer.fromJSON(e));
            }
        }
        if (object.mimeType !== undefined && object.mimeType !== null) {
            message.mimeType = String(object.mimeType);
        }
        else {
            message.mimeType = "";
        }
        if (object.mid !== undefined && object.mid !== null) {
            message.mid = String(object.mid);
        }
        else {
            message.mid = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sid !== undefined && (obj.sid = message.sid);
        message.type !== undefined && (obj.type = trackTypeToJSON(message.type));
        message.name !== undefined && (obj.name = message.name);
        message.muted !== undefined && (obj.muted = message.muted);
        message.width !== undefined && (obj.width = message.width);
        message.height !== undefined && (obj.height = message.height);
        message.simulcast !== undefined && (obj.simulcast = message.simulcast);
        message.disableDtx !== undefined && (obj.disableDtx = message.disableDtx);
        message.source !== undefined &&
            (obj.source = trackSourceToJSON(message.source));
        if (message.layers) {
            obj.layers = message.layers.map((e) => e ? exports.VideoLayer.toJSON(e) : undefined);
        }
        else {
            obj.layers = [];
        }
        message.mimeType !== undefined && (obj.mimeType = message.mimeType);
        message.mid !== undefined && (obj.mid = message.mid);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const message = Object.assign({}, baseTrackInfo);
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.type = (_b = object.type) !== null && _b !== void 0 ? _b : 0;
        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : "";
        message.muted = (_d = object.muted) !== null && _d !== void 0 ? _d : false;
        message.width = (_e = object.width) !== null && _e !== void 0 ? _e : 0;
        message.height = (_f = object.height) !== null && _f !== void 0 ? _f : 0;
        message.simulcast = (_g = object.simulcast) !== null && _g !== void 0 ? _g : false;
        message.disableDtx = (_h = object.disableDtx) !== null && _h !== void 0 ? _h : false;
        message.source = (_j = object.source) !== null && _j !== void 0 ? _j : 0;
        message.layers = [];
        if (object.layers !== undefined && object.layers !== null) {
            for (const e of object.layers) {
                message.layers.push(exports.VideoLayer.fromPartial(e));
            }
        }
        message.mimeType = (_k = object.mimeType) !== null && _k !== void 0 ? _k : "";
        message.mid = (_l = object.mid) !== null && _l !== void 0 ? _l : "";
        return message;
    },
};
const baseVideoLayer = {
    quality: 0,
    width: 0,
    height: 0,
    bitrate: 0,
    ssrc: 0,
};
exports.VideoLayer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.quality !== 0) {
            writer.uint32(8).int32(message.quality);
        }
        if (message.width !== 0) {
            writer.uint32(16).uint32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(24).uint32(message.height);
        }
        if (message.bitrate !== 0) {
            writer.uint32(32).uint32(message.bitrate);
        }
        if (message.ssrc !== 0) {
            writer.uint32(40).uint32(message.ssrc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseVideoLayer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.quality = reader.int32();
                    break;
                case 2:
                    message.width = reader.uint32();
                    break;
                case 3:
                    message.height = reader.uint32();
                    break;
                case 4:
                    message.bitrate = reader.uint32();
                    break;
                case 5:
                    message.ssrc = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseVideoLayer);
        if (object.quality !== undefined && object.quality !== null) {
            message.quality = videoQualityFromJSON(object.quality);
        }
        else {
            message.quality = 0;
        }
        if (object.width !== undefined && object.width !== null) {
            message.width = Number(object.width);
        }
        else {
            message.width = 0;
        }
        if (object.height !== undefined && object.height !== null) {
            message.height = Number(object.height);
        }
        else {
            message.height = 0;
        }
        if (object.bitrate !== undefined && object.bitrate !== null) {
            message.bitrate = Number(object.bitrate);
        }
        else {
            message.bitrate = 0;
        }
        if (object.ssrc !== undefined && object.ssrc !== null) {
            message.ssrc = Number(object.ssrc);
        }
        else {
            message.ssrc = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.quality !== undefined &&
            (obj.quality = videoQualityToJSON(message.quality));
        message.width !== undefined && (obj.width = message.width);
        message.height !== undefined && (obj.height = message.height);
        message.bitrate !== undefined && (obj.bitrate = message.bitrate);
        message.ssrc !== undefined && (obj.ssrc = message.ssrc);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseVideoLayer);
        message.quality = (_a = object.quality) !== null && _a !== void 0 ? _a : 0;
        message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;
        message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;
        message.bitrate = (_d = object.bitrate) !== null && _d !== void 0 ? _d : 0;
        message.ssrc = (_e = object.ssrc) !== null && _e !== void 0 ? _e : 0;
        return message;
    },
};
const baseDataPacket = { kind: 0 };
exports.DataPacket = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.kind !== 0) {
            writer.uint32(8).int32(message.kind);
        }
        if (message.user !== undefined) {
            exports.UserPacket.encode(message.user, writer.uint32(18).fork()).ldelim();
        }
        if (message.speaker !== undefined) {
            exports.ActiveSpeakerUpdate.encode(message.speaker, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDataPacket);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                case 2:
                    message.user = exports.UserPacket.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.speaker = exports.ActiveSpeakerUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseDataPacket);
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = dataPacket_KindFromJSON(object.kind);
        }
        else {
            message.kind = 0;
        }
        if (object.user !== undefined && object.user !== null) {
            message.user = exports.UserPacket.fromJSON(object.user);
        }
        else {
            message.user = undefined;
        }
        if (object.speaker !== undefined && object.speaker !== null) {
            message.speaker = exports.ActiveSpeakerUpdate.fromJSON(object.speaker);
        }
        else {
            message.speaker = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined &&
            (obj.kind = dataPacket_KindToJSON(message.kind));
        message.user !== undefined &&
            (obj.user = message.user ? exports.UserPacket.toJSON(message.user) : undefined);
        message.speaker !== undefined &&
            (obj.speaker = message.speaker
                ? exports.ActiveSpeakerUpdate.toJSON(message.speaker)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseDataPacket);
        message.kind = (_a = object.kind) !== null && _a !== void 0 ? _a : 0;
        if (object.user !== undefined && object.user !== null) {
            message.user = exports.UserPacket.fromPartial(object.user);
        }
        else {
            message.user = undefined;
        }
        if (object.speaker !== undefined && object.speaker !== null) {
            message.speaker = exports.ActiveSpeakerUpdate.fromPartial(object.speaker);
        }
        else {
            message.speaker = undefined;
        }
        return message;
    },
};
const baseActiveSpeakerUpdate = {};
exports.ActiveSpeakerUpdate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.speakers) {
            exports.SpeakerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseActiveSpeakerUpdate);
        message.speakers = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.speakers.push(exports.SpeakerInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseActiveSpeakerUpdate);
        message.speakers = [];
        if (object.speakers !== undefined && object.speakers !== null) {
            for (const e of object.speakers) {
                message.speakers.push(exports.SpeakerInfo.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.speakers) {
            obj.speakers = message.speakers.map((e) => e ? exports.SpeakerInfo.toJSON(e) : undefined);
        }
        else {
            obj.speakers = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseActiveSpeakerUpdate);
        message.speakers = [];
        if (object.speakers !== undefined && object.speakers !== null) {
            for (const e of object.speakers) {
                message.speakers.push(exports.SpeakerInfo.fromPartial(e));
            }
        }
        return message;
    },
};
const baseSpeakerInfo = { sid: "", level: 0, active: false };
exports.SpeakerInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.level !== 0) {
            writer.uint32(21).float(message.level);
        }
        if (message.active === true) {
            writer.uint32(24).bool(message.active);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpeakerInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sid = reader.string();
                    break;
                case 2:
                    message.level = reader.float();
                    break;
                case 3:
                    message.active = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSpeakerInfo);
        if (object.sid !== undefined && object.sid !== null) {
            message.sid = String(object.sid);
        }
        else {
            message.sid = "";
        }
        if (object.level !== undefined && object.level !== null) {
            message.level = Number(object.level);
        }
        else {
            message.level = 0;
        }
        if (object.active !== undefined && object.active !== null) {
            message.active = Boolean(object.active);
        }
        else {
            message.active = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sid !== undefined && (obj.sid = message.sid);
        message.level !== undefined && (obj.level = message.level);
        message.active !== undefined && (obj.active = message.active);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseSpeakerInfo);
        message.sid = (_a = object.sid) !== null && _a !== void 0 ? _a : "";
        message.level = (_b = object.level) !== null && _b !== void 0 ? _b : 0;
        message.active = (_c = object.active) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
const baseUserPacket = { participantSid: "", destinationSids: "" };
exports.UserPacket = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
            writer.uint32(10).string(message.participantSid);
        }
        if (message.payload.length !== 0) {
            writer.uint32(18).bytes(message.payload);
        }
        for (const v of message.destinationSids) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUserPacket);
        message.destinationSids = [];
        message.payload = new Uint8Array();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participantSid = reader.string();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                case 3:
                    message.destinationSids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUserPacket);
        message.destinationSids = [];
        message.payload = new Uint8Array();
        if (object.participantSid !== undefined && object.participantSid !== null) {
            message.participantSid = String(object.participantSid);
        }
        else {
            message.participantSid = "";
        }
        if (object.payload !== undefined && object.payload !== null) {
            message.payload = bytesFromBase64(object.payload);
        }
        if (object.destinationSids !== undefined &&
            object.destinationSids !== null) {
            for (const e of object.destinationSids) {
                message.destinationSids.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.participantSid !== undefined &&
            (obj.participantSid = message.participantSid);
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        if (message.destinationSids) {
            obj.destinationSids = message.destinationSids.map((e) => e);
        }
        else {
            obj.destinationSids = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseUserPacket);
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.destinationSids = [];
        if (object.destinationSids !== undefined &&
            object.destinationSids !== null) {
            for (const e of object.destinationSids) {
                message.destinationSids.push(e);
            }
        }
        return message;
    },
};
const baseParticipantTracks = { participantSid: "", trackSids: "" };
exports.ParticipantTracks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.participantSid !== "") {
            writer.uint32(10).string(message.participantSid);
        }
        for (const v of message.trackSids) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParticipantTracks);
        message.trackSids = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participantSid = reader.string();
                    break;
                case 2:
                    message.trackSids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseParticipantTracks);
        message.trackSids = [];
        if (object.participantSid !== undefined && object.participantSid !== null) {
            message.participantSid = String(object.participantSid);
        }
        else {
            message.participantSid = "";
        }
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.participantSid !== undefined &&
            (obj.participantSid = message.participantSid);
        if (message.trackSids) {
            obj.trackSids = message.trackSids.map((e) => e);
        }
        else {
            obj.trackSids = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseParticipantTracks);
        message.participantSid = (_a = object.participantSid) !== null && _a !== void 0 ? _a : "";
        message.trackSids = [];
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(e);
            }
        }
        return message;
    },
};
const baseClientInfo = {
    sdk: 0,
    version: "",
    protocol: 0,
    os: "",
    osVersion: "",
    deviceModel: "",
    browser: "",
    browserVersion: "",
    address: "",
};
exports.ClientInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sdk !== 0) {
            writer.uint32(8).int32(message.sdk);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        if (message.protocol !== 0) {
            writer.uint32(24).int32(message.protocol);
        }
        if (message.os !== "") {
            writer.uint32(34).string(message.os);
        }
        if (message.osVersion !== "") {
            writer.uint32(42).string(message.osVersion);
        }
        if (message.deviceModel !== "") {
            writer.uint32(50).string(message.deviceModel);
        }
        if (message.browser !== "") {
            writer.uint32(58).string(message.browser);
        }
        if (message.browserVersion !== "") {
            writer.uint32(66).string(message.browserVersion);
        }
        if (message.address !== "") {
            writer.uint32(74).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sdk = reader.int32();
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                case 3:
                    message.protocol = reader.int32();
                    break;
                case 4:
                    message.os = reader.string();
                    break;
                case 5:
                    message.osVersion = reader.string();
                    break;
                case 6:
                    message.deviceModel = reader.string();
                    break;
                case 7:
                    message.browser = reader.string();
                    break;
                case 8:
                    message.browserVersion = reader.string();
                    break;
                case 9:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseClientInfo);
        if (object.sdk !== undefined && object.sdk !== null) {
            message.sdk = clientInfo_SDKFromJSON(object.sdk);
        }
        else {
            message.sdk = 0;
        }
        if (object.version !== undefined && object.version !== null) {
            message.version = String(object.version);
        }
        else {
            message.version = "";
        }
        if (object.protocol !== undefined && object.protocol !== null) {
            message.protocol = Number(object.protocol);
        }
        else {
            message.protocol = 0;
        }
        if (object.os !== undefined && object.os !== null) {
            message.os = String(object.os);
        }
        else {
            message.os = "";
        }
        if (object.osVersion !== undefined && object.osVersion !== null) {
            message.osVersion = String(object.osVersion);
        }
        else {
            message.osVersion = "";
        }
        if (object.deviceModel !== undefined && object.deviceModel !== null) {
            message.deviceModel = String(object.deviceModel);
        }
        else {
            message.deviceModel = "";
        }
        if (object.browser !== undefined && object.browser !== null) {
            message.browser = String(object.browser);
        }
        else {
            message.browser = "";
        }
        if (object.browserVersion !== undefined && object.browserVersion !== null) {
            message.browserVersion = String(object.browserVersion);
        }
        else {
            message.browserVersion = "";
        }
        if (object.address !== undefined && object.address !== null) {
            message.address = String(object.address);
        }
        else {
            message.address = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.sdk !== undefined && (obj.sdk = clientInfo_SDKToJSON(message.sdk));
        message.version !== undefined && (obj.version = message.version);
        message.protocol !== undefined && (obj.protocol = message.protocol);
        message.os !== undefined && (obj.os = message.os);
        message.osVersion !== undefined && (obj.osVersion = message.osVersion);
        message.deviceModel !== undefined &&
            (obj.deviceModel = message.deviceModel);
        message.browser !== undefined && (obj.browser = message.browser);
        message.browserVersion !== undefined &&
            (obj.browserVersion = message.browserVersion);
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = Object.assign({}, baseClientInfo);
        message.sdk = (_a = object.sdk) !== null && _a !== void 0 ? _a : 0;
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
        message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;
        message.os = (_d = object.os) !== null && _d !== void 0 ? _d : "";
        message.osVersion = (_e = object.osVersion) !== null && _e !== void 0 ? _e : "";
        message.deviceModel = (_f = object.deviceModel) !== null && _f !== void 0 ? _f : "";
        message.browser = (_g = object.browser) !== null && _g !== void 0 ? _g : "";
        message.browserVersion = (_h = object.browserVersion) !== null && _h !== void 0 ? _h : "";
        message.address = (_j = object.address) !== null && _j !== void 0 ? _j : "";
        return message;
    },
};
const baseClientConfiguration = { resumeConnection: 0 };
exports.ClientConfiguration = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.video !== undefined) {
            exports.VideoConfiguration.encode(message.video, writer.uint32(10).fork()).ldelim();
        }
        if (message.screen !== undefined) {
            exports.VideoConfiguration.encode(message.screen, writer.uint32(18).fork()).ldelim();
        }
        if (message.resumeConnection !== 0) {
            writer.uint32(24).int32(message.resumeConnection);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientConfiguration);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.video = exports.VideoConfiguration.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.screen = exports.VideoConfiguration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.resumeConnection = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseClientConfiguration);
        if (object.video !== undefined && object.video !== null) {
            message.video = exports.VideoConfiguration.fromJSON(object.video);
        }
        else {
            message.video = undefined;
        }
        if (object.screen !== undefined && object.screen !== null) {
            message.screen = exports.VideoConfiguration.fromJSON(object.screen);
        }
        else {
            message.screen = undefined;
        }
        if (object.resumeConnection !== undefined &&
            object.resumeConnection !== null) {
            message.resumeConnection = clientConfigSettingFromJSON(object.resumeConnection);
        }
        else {
            message.resumeConnection = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.video !== undefined &&
            (obj.video = message.video
                ? exports.VideoConfiguration.toJSON(message.video)
                : undefined);
        message.screen !== undefined &&
            (obj.screen = message.screen
                ? exports.VideoConfiguration.toJSON(message.screen)
                : undefined);
        message.resumeConnection !== undefined &&
            (obj.resumeConnection = clientConfigSettingToJSON(message.resumeConnection));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseClientConfiguration);
        if (object.video !== undefined && object.video !== null) {
            message.video = exports.VideoConfiguration.fromPartial(object.video);
        }
        else {
            message.video = undefined;
        }
        if (object.screen !== undefined && object.screen !== null) {
            message.screen = exports.VideoConfiguration.fromPartial(object.screen);
        }
        else {
            message.screen = undefined;
        }
        message.resumeConnection = (_a = object.resumeConnection) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
const baseVideoConfiguration = { hardwareEncoder: 0 };
exports.VideoConfiguration = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hardwareEncoder !== 0) {
            writer.uint32(8).int32(message.hardwareEncoder);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseVideoConfiguration);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hardwareEncoder = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseVideoConfiguration);
        if (object.hardwareEncoder !== undefined &&
            object.hardwareEncoder !== null) {
            message.hardwareEncoder = clientConfigSettingFromJSON(object.hardwareEncoder);
        }
        else {
            message.hardwareEncoder = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.hardwareEncoder !== undefined &&
            (obj.hardwareEncoder = clientConfigSettingToJSON(message.hardwareEncoder));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseVideoConfiguration);
        message.hardwareEncoder = (_a = object.hardwareEncoder) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
const baseRTPStats = {
    duration: 0,
    packets: 0,
    packetRate: 0,
    bytes: 0,
    bitrate: 0,
    packetsLost: 0,
    packetLossRate: 0,
    packetLossPercentage: 0,
    packetsDuplicate: 0,
    packetDuplicateRate: 0,
    bytesDuplicate: 0,
    bitrateDuplicate: 0,
    packetsPadding: 0,
    packetPaddingRate: 0,
    bytesPadding: 0,
    bitratePadding: 0,
    packetsOutOfOrder: 0,
    frames: 0,
    frameRate: 0,
    jitterCurrent: 0,
    jitterMax: 0,
    nacks: 0,
    nackMisses: 0,
    plis: 0,
    firs: 0,
    rttCurrent: 0,
    rttMax: 0,
    keyFrames: 0,
    layerLockPlis: 0,
};
exports.RTPStats = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.startTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).ldelim();
        }
        if (message.endTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).ldelim();
        }
        if (message.duration !== 0) {
            writer.uint32(25).double(message.duration);
        }
        if (message.packets !== 0) {
            writer.uint32(32).uint32(message.packets);
        }
        if (message.packetRate !== 0) {
            writer.uint32(41).double(message.packetRate);
        }
        if (message.bytes !== 0) {
            writer.uint32(48).uint64(message.bytes);
        }
        if (message.bitrate !== 0) {
            writer.uint32(57).double(message.bitrate);
        }
        if (message.packetsLost !== 0) {
            writer.uint32(64).uint32(message.packetsLost);
        }
        if (message.packetLossRate !== 0) {
            writer.uint32(73).double(message.packetLossRate);
        }
        if (message.packetLossPercentage !== 0) {
            writer.uint32(85).float(message.packetLossPercentage);
        }
        if (message.packetsDuplicate !== 0) {
            writer.uint32(88).uint32(message.packetsDuplicate);
        }
        if (message.packetDuplicateRate !== 0) {
            writer.uint32(97).double(message.packetDuplicateRate);
        }
        if (message.bytesDuplicate !== 0) {
            writer.uint32(104).uint64(message.bytesDuplicate);
        }
        if (message.bitrateDuplicate !== 0) {
            writer.uint32(113).double(message.bitrateDuplicate);
        }
        if (message.packetsPadding !== 0) {
            writer.uint32(120).uint32(message.packetsPadding);
        }
        if (message.packetPaddingRate !== 0) {
            writer.uint32(129).double(message.packetPaddingRate);
        }
        if (message.bytesPadding !== 0) {
            writer.uint32(136).uint64(message.bytesPadding);
        }
        if (message.bitratePadding !== 0) {
            writer.uint32(145).double(message.bitratePadding);
        }
        if (message.packetsOutOfOrder !== 0) {
            writer.uint32(152).uint32(message.packetsOutOfOrder);
        }
        if (message.frames !== 0) {
            writer.uint32(160).uint32(message.frames);
        }
        if (message.frameRate !== 0) {
            writer.uint32(169).double(message.frameRate);
        }
        if (message.jitterCurrent !== 0) {
            writer.uint32(177).double(message.jitterCurrent);
        }
        if (message.jitterMax !== 0) {
            writer.uint32(185).double(message.jitterMax);
        }
        Object.entries(message.gapHistogram).forEach(([key, value]) => {
            exports.RTPStats_GapHistogramEntry.encode({ key: key, value }, writer.uint32(194).fork()).ldelim();
        });
        if (message.nacks !== 0) {
            writer.uint32(200).uint32(message.nacks);
        }
        if (message.nackMisses !== 0) {
            writer.uint32(208).uint32(message.nackMisses);
        }
        if (message.plis !== 0) {
            writer.uint32(216).uint32(message.plis);
        }
        if (message.lastPli !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.lastPli), writer.uint32(226).fork()).ldelim();
        }
        if (message.firs !== 0) {
            writer.uint32(232).uint32(message.firs);
        }
        if (message.lastFir !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.lastFir), writer.uint32(242).fork()).ldelim();
        }
        if (message.rttCurrent !== 0) {
            writer.uint32(248).uint32(message.rttCurrent);
        }
        if (message.rttMax !== 0) {
            writer.uint32(256).uint32(message.rttMax);
        }
        if (message.keyFrames !== 0) {
            writer.uint32(264).uint32(message.keyFrames);
        }
        if (message.lastKeyFrame !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.lastKeyFrame), writer.uint32(274).fork()).ldelim();
        }
        if (message.layerLockPlis !== 0) {
            writer.uint32(280).uint32(message.layerLockPlis);
        }
        if (message.lastLayerLockPli !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.lastLayerLockPli), writer.uint32(290).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRTPStats);
        message.gapHistogram = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.startTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.endTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.duration = reader.double();
                    break;
                case 4:
                    message.packets = reader.uint32();
                    break;
                case 5:
                    message.packetRate = reader.double();
                    break;
                case 6:
                    message.bytes = longToNumber(reader.uint64());
                    break;
                case 7:
                    message.bitrate = reader.double();
                    break;
                case 8:
                    message.packetsLost = reader.uint32();
                    break;
                case 9:
                    message.packetLossRate = reader.double();
                    break;
                case 10:
                    message.packetLossPercentage = reader.float();
                    break;
                case 11:
                    message.packetsDuplicate = reader.uint32();
                    break;
                case 12:
                    message.packetDuplicateRate = reader.double();
                    break;
                case 13:
                    message.bytesDuplicate = longToNumber(reader.uint64());
                    break;
                case 14:
                    message.bitrateDuplicate = reader.double();
                    break;
                case 15:
                    message.packetsPadding = reader.uint32();
                    break;
                case 16:
                    message.packetPaddingRate = reader.double();
                    break;
                case 17:
                    message.bytesPadding = longToNumber(reader.uint64());
                    break;
                case 18:
                    message.bitratePadding = reader.double();
                    break;
                case 19:
                    message.packetsOutOfOrder = reader.uint32();
                    break;
                case 20:
                    message.frames = reader.uint32();
                    break;
                case 21:
                    message.frameRate = reader.double();
                    break;
                case 22:
                    message.jitterCurrent = reader.double();
                    break;
                case 23:
                    message.jitterMax = reader.double();
                    break;
                case 24:
                    const entry24 = exports.RTPStats_GapHistogramEntry.decode(reader, reader.uint32());
                    if (entry24.value !== undefined) {
                        message.gapHistogram[entry24.key] = entry24.value;
                    }
                    break;
                case 25:
                    message.nacks = reader.uint32();
                    break;
                case 26:
                    message.nackMisses = reader.uint32();
                    break;
                case 27:
                    message.plis = reader.uint32();
                    break;
                case 28:
                    message.lastPli = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 29:
                    message.firs = reader.uint32();
                    break;
                case 30:
                    message.lastFir = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 31:
                    message.rttCurrent = reader.uint32();
                    break;
                case 32:
                    message.rttMax = reader.uint32();
                    break;
                case 33:
                    message.keyFrames = reader.uint32();
                    break;
                case 34:
                    message.lastKeyFrame = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 35:
                    message.layerLockPlis = reader.uint32();
                    break;
                case 36:
                    message.lastLayerLockPli = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRTPStats);
        message.gapHistogram = {};
        if (object.startTime !== undefined && object.startTime !== null) {
            message.startTime = fromJsonTimestamp(object.startTime);
        }
        else {
            message.startTime = undefined;
        }
        if (object.endTime !== undefined && object.endTime !== null) {
            message.endTime = fromJsonTimestamp(object.endTime);
        }
        else {
            message.endTime = undefined;
        }
        if (object.duration !== undefined && object.duration !== null) {
            message.duration = Number(object.duration);
        }
        else {
            message.duration = 0;
        }
        if (object.packets !== undefined && object.packets !== null) {
            message.packets = Number(object.packets);
        }
        else {
            message.packets = 0;
        }
        if (object.packetRate !== undefined && object.packetRate !== null) {
            message.packetRate = Number(object.packetRate);
        }
        else {
            message.packetRate = 0;
        }
        if (object.bytes !== undefined && object.bytes !== null) {
            message.bytes = Number(object.bytes);
        }
        else {
            message.bytes = 0;
        }
        if (object.bitrate !== undefined && object.bitrate !== null) {
            message.bitrate = Number(object.bitrate);
        }
        else {
            message.bitrate = 0;
        }
        if (object.packetsLost !== undefined && object.packetsLost !== null) {
            message.packetsLost = Number(object.packetsLost);
        }
        else {
            message.packetsLost = 0;
        }
        if (object.packetLossRate !== undefined && object.packetLossRate !== null) {
            message.packetLossRate = Number(object.packetLossRate);
        }
        else {
            message.packetLossRate = 0;
        }
        if (object.packetLossPercentage !== undefined &&
            object.packetLossPercentage !== null) {
            message.packetLossPercentage = Number(object.packetLossPercentage);
        }
        else {
            message.packetLossPercentage = 0;
        }
        if (object.packetsDuplicate !== undefined &&
            object.packetsDuplicate !== null) {
            message.packetsDuplicate = Number(object.packetsDuplicate);
        }
        else {
            message.packetsDuplicate = 0;
        }
        if (object.packetDuplicateRate !== undefined &&
            object.packetDuplicateRate !== null) {
            message.packetDuplicateRate = Number(object.packetDuplicateRate);
        }
        else {
            message.packetDuplicateRate = 0;
        }
        if (object.bytesDuplicate !== undefined && object.bytesDuplicate !== null) {
            message.bytesDuplicate = Number(object.bytesDuplicate);
        }
        else {
            message.bytesDuplicate = 0;
        }
        if (object.bitrateDuplicate !== undefined &&
            object.bitrateDuplicate !== null) {
            message.bitrateDuplicate = Number(object.bitrateDuplicate);
        }
        else {
            message.bitrateDuplicate = 0;
        }
        if (object.packetsPadding !== undefined && object.packetsPadding !== null) {
            message.packetsPadding = Number(object.packetsPadding);
        }
        else {
            message.packetsPadding = 0;
        }
        if (object.packetPaddingRate !== undefined &&
            object.packetPaddingRate !== null) {
            message.packetPaddingRate = Number(object.packetPaddingRate);
        }
        else {
            message.packetPaddingRate = 0;
        }
        if (object.bytesPadding !== undefined && object.bytesPadding !== null) {
            message.bytesPadding = Number(object.bytesPadding);
        }
        else {
            message.bytesPadding = 0;
        }
        if (object.bitratePadding !== undefined && object.bitratePadding !== null) {
            message.bitratePadding = Number(object.bitratePadding);
        }
        else {
            message.bitratePadding = 0;
        }
        if (object.packetsOutOfOrder !== undefined &&
            object.packetsOutOfOrder !== null) {
            message.packetsOutOfOrder = Number(object.packetsOutOfOrder);
        }
        else {
            message.packetsOutOfOrder = 0;
        }
        if (object.frames !== undefined && object.frames !== null) {
            message.frames = Number(object.frames);
        }
        else {
            message.frames = 0;
        }
        if (object.frameRate !== undefined && object.frameRate !== null) {
            message.frameRate = Number(object.frameRate);
        }
        else {
            message.frameRate = 0;
        }
        if (object.jitterCurrent !== undefined && object.jitterCurrent !== null) {
            message.jitterCurrent = Number(object.jitterCurrent);
        }
        else {
            message.jitterCurrent = 0;
        }
        if (object.jitterMax !== undefined && object.jitterMax !== null) {
            message.jitterMax = Number(object.jitterMax);
        }
        else {
            message.jitterMax = 0;
        }
        if (object.gapHistogram !== undefined && object.gapHistogram !== null) {
            Object.entries(object.gapHistogram).forEach(([key, value]) => {
                message.gapHistogram[Number(key)] = Number(value);
            });
        }
        if (object.nacks !== undefined && object.nacks !== null) {
            message.nacks = Number(object.nacks);
        }
        else {
            message.nacks = 0;
        }
        if (object.nackMisses !== undefined && object.nackMisses !== null) {
            message.nackMisses = Number(object.nackMisses);
        }
        else {
            message.nackMisses = 0;
        }
        if (object.plis !== undefined && object.plis !== null) {
            message.plis = Number(object.plis);
        }
        else {
            message.plis = 0;
        }
        if (object.lastPli !== undefined && object.lastPli !== null) {
            message.lastPli = fromJsonTimestamp(object.lastPli);
        }
        else {
            message.lastPli = undefined;
        }
        if (object.firs !== undefined && object.firs !== null) {
            message.firs = Number(object.firs);
        }
        else {
            message.firs = 0;
        }
        if (object.lastFir !== undefined && object.lastFir !== null) {
            message.lastFir = fromJsonTimestamp(object.lastFir);
        }
        else {
            message.lastFir = undefined;
        }
        if (object.rttCurrent !== undefined && object.rttCurrent !== null) {
            message.rttCurrent = Number(object.rttCurrent);
        }
        else {
            message.rttCurrent = 0;
        }
        if (object.rttMax !== undefined && object.rttMax !== null) {
            message.rttMax = Number(object.rttMax);
        }
        else {
            message.rttMax = 0;
        }
        if (object.keyFrames !== undefined && object.keyFrames !== null) {
            message.keyFrames = Number(object.keyFrames);
        }
        else {
            message.keyFrames = 0;
        }
        if (object.lastKeyFrame !== undefined && object.lastKeyFrame !== null) {
            message.lastKeyFrame = fromJsonTimestamp(object.lastKeyFrame);
        }
        else {
            message.lastKeyFrame = undefined;
        }
        if (object.layerLockPlis !== undefined && object.layerLockPlis !== null) {
            message.layerLockPlis = Number(object.layerLockPlis);
        }
        else {
            message.layerLockPlis = 0;
        }
        if (object.lastLayerLockPli !== undefined &&
            object.lastLayerLockPli !== null) {
            message.lastLayerLockPli = fromJsonTimestamp(object.lastLayerLockPli);
        }
        else {
            message.lastLayerLockPli = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.startTime !== undefined &&
            (obj.startTime = message.startTime.toISOString());
        message.endTime !== undefined &&
            (obj.endTime = message.endTime.toISOString());
        message.duration !== undefined && (obj.duration = message.duration);
        message.packets !== undefined && (obj.packets = message.packets);
        message.packetRate !== undefined && (obj.packetRate = message.packetRate);
        message.bytes !== undefined && (obj.bytes = message.bytes);
        message.bitrate !== undefined && (obj.bitrate = message.bitrate);
        message.packetsLost !== undefined &&
            (obj.packetsLost = message.packetsLost);
        message.packetLossRate !== undefined &&
            (obj.packetLossRate = message.packetLossRate);
        message.packetLossPercentage !== undefined &&
            (obj.packetLossPercentage = message.packetLossPercentage);
        message.packetsDuplicate !== undefined &&
            (obj.packetsDuplicate = message.packetsDuplicate);
        message.packetDuplicateRate !== undefined &&
            (obj.packetDuplicateRate = message.packetDuplicateRate);
        message.bytesDuplicate !== undefined &&
            (obj.bytesDuplicate = message.bytesDuplicate);
        message.bitrateDuplicate !== undefined &&
            (obj.bitrateDuplicate = message.bitrateDuplicate);
        message.packetsPadding !== undefined &&
            (obj.packetsPadding = message.packetsPadding);
        message.packetPaddingRate !== undefined &&
            (obj.packetPaddingRate = message.packetPaddingRate);
        message.bytesPadding !== undefined &&
            (obj.bytesPadding = message.bytesPadding);
        message.bitratePadding !== undefined &&
            (obj.bitratePadding = message.bitratePadding);
        message.packetsOutOfOrder !== undefined &&
            (obj.packetsOutOfOrder = message.packetsOutOfOrder);
        message.frames !== undefined && (obj.frames = message.frames);
        message.frameRate !== undefined && (obj.frameRate = message.frameRate);
        message.jitterCurrent !== undefined &&
            (obj.jitterCurrent = message.jitterCurrent);
        message.jitterMax !== undefined && (obj.jitterMax = message.jitterMax);
        obj.gapHistogram = {};
        if (message.gapHistogram) {
            Object.entries(message.gapHistogram).forEach(([k, v]) => {
                obj.gapHistogram[k] = v;
            });
        }
        message.nacks !== undefined && (obj.nacks = message.nacks);
        message.nackMisses !== undefined && (obj.nackMisses = message.nackMisses);
        message.plis !== undefined && (obj.plis = message.plis);
        message.lastPli !== undefined &&
            (obj.lastPli = message.lastPli.toISOString());
        message.firs !== undefined && (obj.firs = message.firs);
        message.lastFir !== undefined &&
            (obj.lastFir = message.lastFir.toISOString());
        message.rttCurrent !== undefined && (obj.rttCurrent = message.rttCurrent);
        message.rttMax !== undefined && (obj.rttMax = message.rttMax);
        message.keyFrames !== undefined && (obj.keyFrames = message.keyFrames);
        message.lastKeyFrame !== undefined &&
            (obj.lastKeyFrame = message.lastKeyFrame.toISOString());
        message.layerLockPlis !== undefined &&
            (obj.layerLockPlis = message.layerLockPlis);
        message.lastLayerLockPli !== undefined &&
            (obj.lastLayerLockPli = message.lastLayerLockPli.toISOString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
        const message = Object.assign({}, baseRTPStats);
        message.startTime = (_a = object.startTime) !== null && _a !== void 0 ? _a : undefined;
        message.endTime = (_b = object.endTime) !== null && _b !== void 0 ? _b : undefined;
        message.duration = (_c = object.duration) !== null && _c !== void 0 ? _c : 0;
        message.packets = (_d = object.packets) !== null && _d !== void 0 ? _d : 0;
        message.packetRate = (_e = object.packetRate) !== null && _e !== void 0 ? _e : 0;
        message.bytes = (_f = object.bytes) !== null && _f !== void 0 ? _f : 0;
        message.bitrate = (_g = object.bitrate) !== null && _g !== void 0 ? _g : 0;
        message.packetsLost = (_h = object.packetsLost) !== null && _h !== void 0 ? _h : 0;
        message.packetLossRate = (_j = object.packetLossRate) !== null && _j !== void 0 ? _j : 0;
        message.packetLossPercentage = (_k = object.packetLossPercentage) !== null && _k !== void 0 ? _k : 0;
        message.packetsDuplicate = (_l = object.packetsDuplicate) !== null && _l !== void 0 ? _l : 0;
        message.packetDuplicateRate = (_m = object.packetDuplicateRate) !== null && _m !== void 0 ? _m : 0;
        message.bytesDuplicate = (_o = object.bytesDuplicate) !== null && _o !== void 0 ? _o : 0;
        message.bitrateDuplicate = (_p = object.bitrateDuplicate) !== null && _p !== void 0 ? _p : 0;
        message.packetsPadding = (_q = object.packetsPadding) !== null && _q !== void 0 ? _q : 0;
        message.packetPaddingRate = (_r = object.packetPaddingRate) !== null && _r !== void 0 ? _r : 0;
        message.bytesPadding = (_s = object.bytesPadding) !== null && _s !== void 0 ? _s : 0;
        message.bitratePadding = (_t = object.bitratePadding) !== null && _t !== void 0 ? _t : 0;
        message.packetsOutOfOrder = (_u = object.packetsOutOfOrder) !== null && _u !== void 0 ? _u : 0;
        message.frames = (_v = object.frames) !== null && _v !== void 0 ? _v : 0;
        message.frameRate = (_w = object.frameRate) !== null && _w !== void 0 ? _w : 0;
        message.jitterCurrent = (_x = object.jitterCurrent) !== null && _x !== void 0 ? _x : 0;
        message.jitterMax = (_y = object.jitterMax) !== null && _y !== void 0 ? _y : 0;
        message.gapHistogram = {};
        if (object.gapHistogram !== undefined && object.gapHistogram !== null) {
            Object.entries(object.gapHistogram).forEach(([key, value]) => {
                if (value !== undefined) {
                    message.gapHistogram[Number(key)] = Number(value);
                }
            });
        }
        message.nacks = (_z = object.nacks) !== null && _z !== void 0 ? _z : 0;
        message.nackMisses = (_0 = object.nackMisses) !== null && _0 !== void 0 ? _0 : 0;
        message.plis = (_1 = object.plis) !== null && _1 !== void 0 ? _1 : 0;
        message.lastPli = (_2 = object.lastPli) !== null && _2 !== void 0 ? _2 : undefined;
        message.firs = (_3 = object.firs) !== null && _3 !== void 0 ? _3 : 0;
        message.lastFir = (_4 = object.lastFir) !== null && _4 !== void 0 ? _4 : undefined;
        message.rttCurrent = (_5 = object.rttCurrent) !== null && _5 !== void 0 ? _5 : 0;
        message.rttMax = (_6 = object.rttMax) !== null && _6 !== void 0 ? _6 : 0;
        message.keyFrames = (_7 = object.keyFrames) !== null && _7 !== void 0 ? _7 : 0;
        message.lastKeyFrame = (_8 = object.lastKeyFrame) !== null && _8 !== void 0 ? _8 : undefined;
        message.layerLockPlis = (_9 = object.layerLockPlis) !== null && _9 !== void 0 ? _9 : 0;
        message.lastLayerLockPli = (_10 = object.lastLayerLockPli) !== null && _10 !== void 0 ? _10 : undefined;
        return message;
    },
};
const baseRTPStats_GapHistogramEntry = { key: 0, value: 0 };
exports.RTPStats_GapHistogramEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== 0) {
            writer.uint32(8).int32(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).uint32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRTPStats_GapHistogramEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.int32();
                    break;
                case 2:
                    message.value = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRTPStats_GapHistogramEntry);
        if (object.key !== undefined && object.key !== null) {
            message.key = Number(object.key);
        }
        else {
            message.key = 0;
        }
        if (object.value !== undefined && object.value !== null) {
            message.value = Number(object.value);
        }
        else {
            message.value = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseRTPStats_GapHistogramEntry);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
    }
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=livekit_models.js.map