"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.videoLayersFromEncodings = exports.videoQualityForRid = void 0;
const logger_1 = __importDefault(require("../../logger"));
const livekit_models_1 = require("../../proto/livekit_models");
const stats_1 = require("../stats");
const utils_1 = require("../utils");
const LocalTrack_1 = __importDefault(require("./LocalTrack"));
const Track_1 = require("./Track");
const utils_2 = require("./utils");
class LocalVideoTrack extends LocalTrack_1.default {
    constructor(mediaTrack, constraints) {
        super(mediaTrack, Track_1.Track.Kind.Video, constraints);
        this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.sender) {
                this._currentBitrate = 0;
                return;
            }
            let stats;
            try {
                stats = yield this.getSenderStats();
            }
            catch (e) {
                logger_1.default.error('could not get audio sender stats', e);
                return;
            }
            const statsMap = new Map(stats.map((s) => [s.rid, s]));
            if (this.prevStats) {
                let totalBitrate = 0;
                statsMap.forEach((s, key) => {
                    var _a;
                    const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);
                    totalBitrate += stats_1.computeBitrate(s, prev);
                });
                this._currentBitrate = totalBitrate;
            }
            this.prevStats = statsMap;
            setTimeout(() => {
                this.monitorSender();
            }, stats_1.monitorFrequency);
        });
    }
    get isSimulcast() {
        if (this.sender && this.sender.getParameters().encodings.length > 1) {
            return true;
        }
        return false;
    }
    /* @internal */
    startMonitor(signalClient) {
        var _a;
        this.signalClient = signalClient;
        // save original encodings
        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();
        if (params) {
            this.encodings = params.encodings;
        }
        setTimeout(() => {
            this.monitorSender();
        }, stats_1.monitorFrequency);
    }
    stop() {
        this.sender = undefined;
        this.mediaStreamTrack.getConstraints();
        super.stop();
    }
    mute() {
        const _super = Object.create(null, {
            mute: { get: () => super.mute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.source === Track_1.Track.Source.Camera) {
                logger_1.default.debug('stopping camera track');
                // also stop the track, so that camera indicator is turned off
                this.mediaStreamTrack.stop();
            }
            yield _super.mute.call(this);
            return this;
        });
    }
    unmute() {
        const _super = Object.create(null, {
            unmute: { get: () => super.unmute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.source === Track_1.Track.Source.Camera) {
                logger_1.default.debug('reacquiring camera track');
                yield this.restartTrack();
            }
            yield _super.unmute.call(this);
            return this;
        });
    }
    getSenderStats() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sender) {
                return [];
            }
            const items = [];
            const stats = yield this.sender.getStats();
            stats.forEach((v) => {
                var _a;
                if (v.type === 'outbound-rtp') {
                    const vs = {
                        type: 'video',
                        streamId: v.id,
                        frameHeight: v.frameHeight,
                        frameWidth: v.frameWidth,
                        firCount: v.firCount,
                        pliCount: v.pliCount,
                        nackCount: v.nackCount,
                        packetsSent: v.packetsSent,
                        bytesSent: v.bytesSent,
                        framesSent: v.framesSent,
                        timestamp: v.timestamp,
                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : '',
                        retransmittedPacketsSent: v.retransmittedPacketsSent,
                        qualityLimitationReason: v.qualityLimitationReason,
                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,
                    };
                    // locate the appropriate remote-inbound-rtp item
                    const r = stats.get(v.remoteId);
                    if (r) {
                        vs.jitter = r.jitter;
                        vs.packetsLost = r.packetsLost;
                        vs.roundTripTime = r.roundTripTime;
                    }
                    items.push(vs);
                }
            });
            return items;
        });
    }
    setPublishingQuality(maxQuality) {
        const qualities = [];
        for (let q = livekit_models_1.VideoQuality.LOW; q <= livekit_models_1.VideoQuality.HIGH; q += 1) {
            qualities.push({
                quality: q,
                enabled: q <= maxQuality,
            });
        }
        logger_1.default.debug('setting publishing quality. max quality', maxQuality);
        this.setPublishingLayers(qualities);
    }
    setDeviceId(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.constraints.deviceId === deviceId) {
                return;
            }
            this.constraints.deviceId = deviceId;
            // when video is muted, underlying media stream track is stopped and
            // will be restarted later
            if (!this.isMuted) {
                yield this.restartTrack();
            }
        });
    }
    restartTrack(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let constraints;
            if (options) {
                const streamConstraints = utils_2.constraintsForOptions({ video: options });
                if (typeof streamConstraints.video !== 'boolean') {
                    constraints = streamConstraints.video;
                }
            }
            yield this.restart(constraints);
        });
    }
    /**
     * @internal
     * Sets layers that should be publishing
     */
    setPublishingLayers(qualities) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug('setting publishing layers', qualities);
            if (!this.sender || !this.encodings) {
                return;
            }
            const params = this.sender.getParameters();
            const { encodings } = params;
            if (!encodings) {
                return;
            }
            if (encodings.length !== this.encodings.length) {
                logger_1.default.warn('cannot set publishing layers, encodings mismatch');
                return;
            }
            let hasChanged = false;
            encodings.forEach((encoding, idx) => {
                var _a;
                let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : '';
                if (rid === '') {
                    rid = 'q';
                }
                const quality = videoQualityForRid(rid);
                const subscribedQuality = qualities.find((q) => q.quality === quality);
                if (!subscribedQuality) {
                    return;
                }
                if (encoding.active !== subscribedQuality.enabled) {
                    hasChanged = true;
                    encoding.active = subscribedQuality.enabled;
                    logger_1.default.debug(`setting layer ${subscribedQuality.quality} to ${encoding.active ? 'enabled' : 'disabled'}`);
                    // FireFox does not support setting encoding.active to false, so we
                    // have a workaround of lowering its bitrate and resolution to the min.
                    if (utils_1.isFireFox()) {
                        if (subscribedQuality.enabled) {
                            encoding.scaleResolutionDownBy = this.encodings[idx].scaleResolutionDownBy;
                            encoding.maxBitrate = this.encodings[idx].maxBitrate;
                            /* @ts-ignore */
                            encoding.maxFrameRate = this.encodings[idx].maxFrameRate;
                        }
                        else {
                            encoding.scaleResolutionDownBy = 4;
                            encoding.maxBitrate = 10;
                            /* @ts-ignore */
                            encoding.maxFrameRate = 2;
                        }
                    }
                }
            });
            if (hasChanged) {
                params.encodings = encodings;
                yield this.sender.setParameters(params);
            }
        });
    }
    handleAppVisibilityChanged() {
        const _super = Object.create(null, {
            handleAppVisibilityChanged: { get: () => super.handleAppVisibilityChanged }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.handleAppVisibilityChanged.call(this);
            if (!utils_1.isMobile())
                return;
            if (this.isInBackground && this.source === Track_1.Track.Source.Camera) {
                this.mediaStreamTrack.enabled = false;
            }
        });
    }
}
exports.default = LocalVideoTrack;
function videoQualityForRid(rid) {
    switch (rid) {
        case 'f':
            return livekit_models_1.VideoQuality.HIGH;
        case 'h':
            return livekit_models_1.VideoQuality.MEDIUM;
        case 'q':
            return livekit_models_1.VideoQuality.LOW;
        default:
            return livekit_models_1.VideoQuality.UNRECOGNIZED;
    }
}
exports.videoQualityForRid = videoQualityForRid;
function videoLayersFromEncodings(width, height, encodings) {
    // default to a single layer, HQ
    if (!encodings) {
        return [{
                quality: livekit_models_1.VideoQuality.HIGH,
                width,
                height,
                bitrate: 0,
                ssrc: 0,
            }];
    }
    return encodings.map((encoding) => {
        var _a, _b, _c;
        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;
        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : '');
        if (quality === livekit_models_1.VideoQuality.UNRECOGNIZED && encodings.length === 1) {
            quality = livekit_models_1.VideoQuality.HIGH;
        }
        return {
            quality,
            width: width / scale,
            height: height / scale,
            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,
            ssrc: 0,
        };
    });
}
exports.videoLayersFromEncodings = videoLayersFromEncodings;
//# sourceMappingURL=LocalVideoTrack.js.map