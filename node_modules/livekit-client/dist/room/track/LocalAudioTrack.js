"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../../logger"));
const events_1 = require("../events");
const stats_1 = require("../stats");
const LocalTrack_1 = __importDefault(require("./LocalTrack"));
const Track_1 = require("./Track");
const utils_1 = require("./utils");
class LocalAudioTrack extends LocalTrack_1.default {
    constructor(mediaTrack, constraints) {
        super(mediaTrack, Track_1.Track.Kind.Audio, constraints);
        /** @internal */
        this.stopOnMute = false;
        this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.sender) {
                this._currentBitrate = 0;
                return;
            }
            let stats;
            try {
                stats = yield this.getSenderStats();
            }
            catch (e) {
                logger_1.default.error('could not get audio sender stats', e);
                return;
            }
            if (stats && this.prevStats) {
                this._currentBitrate = stats_1.computeBitrate(stats, this.prevStats);
            }
            this.prevStats = stats;
            setTimeout(() => {
                this.monitorSender();
            }, stats_1.monitorFrequency);
        });
        this.checkForSilence();
    }
    setDeviceId(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.constraints.deviceId === deviceId) {
                return;
            }
            this.constraints.deviceId = deviceId;
            if (!this.isMuted) {
                yield this.restartTrack();
            }
        });
    }
    mute() {
        const _super = Object.create(null, {
            mute: { get: () => super.mute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // disabled special handling as it will cause BT headsets to switch communication modes
            if (this.source === Track_1.Track.Source.Microphone && this.stopOnMute) {
                logger_1.default.debug('stopping mic track');
                // also stop the track, so that microphone indicator is turned off
                this.mediaStreamTrack.stop();
            }
            yield _super.mute.call(this);
            return this;
        });
    }
    unmute() {
        const _super = Object.create(null, {
            unmute: { get: () => super.unmute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.source === Track_1.Track.Source.Microphone && this.stopOnMute) {
                logger_1.default.debug('reacquiring mic track');
                yield this.restartTrack();
            }
            yield _super.unmute.call(this);
            return this;
        });
    }
    restartTrack(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let constraints;
            if (options) {
                const streamConstraints = utils_1.constraintsForOptions({ audio: options });
                if (typeof streamConstraints.audio !== 'boolean') {
                    constraints = streamConstraints.audio;
                }
            }
            yield this.restart(constraints);
        });
    }
    restart(constraints) {
        const _super = Object.create(null, {
            restart: { get: () => super.restart }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const track = yield _super.restart.call(this, constraints);
            this.checkForSilence();
            return track;
        });
    }
    /* @internal */
    startMonitor() {
        setTimeout(() => {
            this.monitorSender();
        }, stats_1.monitorFrequency);
    }
    getSenderStats() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sender) {
                return undefined;
            }
            const stats = yield this.sender.getStats();
            let audioStats;
            stats.forEach((v) => {
                if (v.type === 'outbound-rtp') {
                    audioStats = {
                        type: 'audio',
                        streamId: v.id,
                        packetsSent: v.packetsSent,
                        packetsLost: v.packetsLost,
                        bytesSent: v.bytesSent,
                        timestamp: v.timestamp,
                        roundTripTime: v.roundTripTime,
                        jitter: v.jitter,
                    };
                }
            });
            return audioStats;
        });
    }
    checkForSilence() {
        return __awaiter(this, void 0, void 0, function* () {
            const trackIsSilent = yield utils_1.detectSilence(this);
            if (trackIsSilent) {
                if (!this.isMuted) {
                    logger_1.default.warn('silence detected on local audio track');
                }
                this.emit(events_1.TrackEvent.AudioSilenceDetected);
            }
        });
    }
}
exports.default = LocalAudioTrack;
//# sourceMappingURL=LocalAudioTrack.js.map