"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../../logger"));
const livekit_models_1 = require("../../proto/livekit_models");
const livekit_rtc_1 = require("../../proto/livekit_rtc");
const events_1 = require("../events");
const RemoteVideoTrack_1 = __importDefault(require("./RemoteVideoTrack"));
const TrackPublication_1 = require("./TrackPublication");
class RemoteTrackPublication extends TrackPublication_1.TrackPublication {
    constructor() {
        super(...arguments);
        /** @internal */
        this._allowed = true;
        this.disabled = false;
        this.currentVideoQuality = livekit_models_1.VideoQuality.HIGH;
        this.handleEnded = (track) => {
            this.emit(events_1.TrackEvent.Ended, track);
        };
        this.handleVisibilityChange = (visible) => {
            logger_1.default.debug('adaptivestream video visibility', this.trackSid, `visible=${visible}`);
            this.disabled = !visible;
            this.emitTrackUpdate();
        };
        this.handleVideoDimensionsChange = (dimensions) => {
            logger_1.default.debug('adaptivestream video dimensions', this.trackSid, `${dimensions.width}x${dimensions.height}`);
            this.videoDimensions = dimensions;
            this.emitTrackUpdate();
        };
    }
    /**
     * Subscribe or unsubscribe to this remote track
     * @param subscribed true to subscribe to a track, false to unsubscribe
     */
    setSubscribed(subscribed) {
        this.subscribed = subscribed;
        const sub = {
            trackSids: [this.trackSid],
            subscribe: this.subscribed,
            participantTracks: [{
                    // sending an empty participant id since TrackPublication doesn't keep it
                    // this is filled in by the participant that receives this message
                    participantSid: '',
                    trackSids: [this.trackSid],
                }],
        };
        this.emit(events_1.TrackEvent.UpdateSubscription, sub);
    }
    get subscriptionStatus() {
        if (this.subscribed === false || !super.isSubscribed) {
            return TrackPublication_1.TrackPublication.SubscriptionStatus.Unsubscribed;
        }
        if (!this._allowed) {
            return TrackPublication_1.TrackPublication.SubscriptionStatus.NotAllowed;
        }
        return TrackPublication_1.TrackPublication.SubscriptionStatus.Subscribed;
    }
    /**
     * Returns true if track is subscribed, and ready for playback
     */
    get isSubscribed() {
        if (this.subscribed === false) {
            return false;
        }
        if (!this._allowed) {
            return false;
        }
        return super.isSubscribed;
    }
    get isEnabled() {
        return !this.disabled;
    }
    /**
     * disable server from sending down data for this track. this is useful when
     * the participant is off screen, you may disable streaming down their video
     * to reduce bandwidth requirements
     * @param enabled
     */
    setEnabled(enabled) {
        if (!this.isManualOperationAllowed() || this.disabled === !enabled) {
            return;
        }
        this.disabled = !enabled;
        this.emitTrackUpdate();
    }
    /**
     * for tracks that support simulcasting, adjust subscribed quality
     *
     * This indicates the highest quality the client can accept. if network
     * bandwidth does not allow, server will automatically reduce quality to
     * optimize for uninterrupted video
     */
    setVideoQuality(quality) {
        if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {
            return;
        }
        this.currentVideoQuality = quality;
        this.videoDimensions = undefined;
        this.emitTrackUpdate();
    }
    setVideoDimensions(dimensions) {
        var _a, _b;
        if (!this.isManualOperationAllowed()) {
            return;
        }
        if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width
            && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {
            return;
        }
        if (this.track instanceof RemoteVideoTrack_1.default) {
            this.videoDimensions = dimensions;
        }
        this.currentVideoQuality = undefined;
        this.emitTrackUpdate();
    }
    get videoQuality() {
        return this.currentVideoQuality;
    }
    setTrack(track) {
        if (this.track) {
            // unregister listener
            this.track.off(events_1.TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
            this.track.off(events_1.TrackEvent.VisibilityChanged, this.handleVisibilityChange);
            this.track.off(events_1.TrackEvent.Ended, this.handleEnded);
        }
        super.setTrack(track);
        if (track) {
            track.sid = this.trackSid;
            track.on(events_1.TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
            track.on(events_1.TrackEvent.VisibilityChanged, this.handleVisibilityChange);
            track.on(events_1.TrackEvent.Ended, this.handleEnded);
        }
    }
    /** @internal */
    updateInfo(info) {
        var _a;
        super.updateInfo(info);
        this.metadataMuted = info.muted;
        (_a = this.track) === null || _a === void 0 ? void 0 : _a.setMuted(info.muted);
    }
    isManualOperationAllowed() {
        if (this.isAdaptiveStream) {
            logger_1.default.warn('adaptive stream is enabled, cannot change track settings', this.trackSid);
            return false;
        }
        if (!this.isSubscribed) {
            logger_1.default.warn('cannot update track settings when not subscribed', this.trackSid);
            return false;
        }
        return true;
    }
    get isAdaptiveStream() {
        return this.track instanceof RemoteVideoTrack_1.default && this.track.isAdaptiveStream;
    }
    /* @internal */
    emitTrackUpdate() {
        const settings = livekit_rtc_1.UpdateTrackSettings.fromPartial({
            trackSids: [this.trackSid],
            disabled: this.disabled,
        });
        if (this.videoDimensions) {
            settings.width = this.videoDimensions.width;
            settings.height = this.videoDimensions.height;
        }
        else if (this.currentVideoQuality !== undefined) {
            settings.quality = this.currentVideoQuality;
        }
        else {
            // defaults to high quality
            settings.quality = livekit_models_1.VideoQuality.HIGH;
        }
        this.emit(events_1.TrackEvent.UpdateSettings, settings);
    }
}
exports.default = RemoteTrackPublication;
//# sourceMappingURL=RemoteTrackPublication.js.map