"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts_debounce_1 = require("ts-debounce");
const events_1 = require("../events");
const stats_1 = require("../stats");
const utils_1 = require("../utils");
const RemoteTrack_1 = __importDefault(require("./RemoteTrack"));
const Track_1 = require("./Track");
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack_1.default {
    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings) {
        super(mediaTrack, sid, Track_1.Track.Kind.Video, receiver);
        this.elementInfos = [];
        this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.receiver) {
                this._currentBitrate = 0;
                return;
            }
            const stats = yield this.getReceiverStats();
            if (stats && this.prevStats && this.receiver) {
                this._currentBitrate = stats_1.computeBitrate(stats, this.prevStats);
            }
            this.prevStats = stats;
            setTimeout(() => {
                this.monitorReceiver();
            }, stats_1.monitorFrequency);
        });
        this.handleVisibilityChanged = (entry) => {
            const { target, isIntersecting } = entry;
            const elementInfo = this.elementInfos.find((info) => info.element === target);
            if (elementInfo) {
                elementInfo.visible = isIntersecting;
                elementInfo.visibilityChangedAt = Date.now();
            }
            this.updateVisibility();
        };
        this.debouncedHandleResize = ts_debounce_1.debounce(() => {
            this.updateDimensions();
        }, REACTION_DELAY);
        this.adaptiveStreamSettings = adaptiveStreamSettings;
    }
    get isAdaptiveStream() {
        return this.adaptiveStreamSettings !== undefined;
    }
    /** @internal */
    setMuted(muted) {
        super.setMuted(muted);
        this.attachedElements.forEach((element) => {
            // detach or attach
            if (muted) {
                Track_1.detachTrack(this.mediaStreamTrack, element);
            }
            else {
                Track_1.attachToElement(this.mediaStreamTrack, element);
            }
        });
    }
    attach(element) {
        if (!element) {
            element = super.attach();
        }
        else {
            super.attach(element);
        }
        // It's possible attach is called multiple times on an element. When that's
        // the case, we'd want to avoid adding duplicate elementInfos
        if (this.adaptiveStreamSettings
            && this.elementInfos.find((info) => info.element === element) === undefined) {
            this.elementInfos.push({
                element,
                visible: true, // default visible
            });
            element
                .handleResize = this.debouncedHandleResize;
            element
                .handleVisibilityChanged = this.handleVisibilityChanged;
            utils_1.getIntersectionObserver().observe(element);
            utils_1.getResizeObserver().observe(element);
            // trigger the first resize update cycle
            // if the tab is backgrounded, the initial resize event does not fire until
            // the tab comes into focus for the first time.
            this.debouncedHandleResize();
        }
        return element;
    }
    detach(element) {
        let detachedElements = [];
        if (element) {
            this.stopObservingElement(element);
            return super.detach(element);
        }
        detachedElements = super.detach();
        for (const e of detachedElements) {
            this.stopObservingElement(e);
        }
        return detachedElements;
    }
    getReceiverStats() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.receiver) {
                return;
            }
            const stats = yield this.receiver.getStats();
            let receiverStats;
            stats.forEach((v) => {
                if (v.type === 'inbound-rtp') {
                    receiverStats = {
                        type: 'video',
                        framesDecoded: v.framesDecoded,
                        framesDropped: v.framesDropped,
                        framesReceived: v.framesReceived,
                        packetsReceived: v.packetsReceived,
                        packetsLost: v.packetsLost,
                        frameWidth: v.frameWidth,
                        frameHeight: v.frameHeight,
                        pliCount: v.pliCount,
                        firCount: v.firCount,
                        nackCount: v.nackCount,
                        jitter: v.jitter,
                        timestamp: v.timestamp,
                        bytesReceived: v.bytesReceived,
                    };
                }
            });
            return receiverStats;
        });
    }
    stopObservingElement(element) {
        var _a, _b;
        (_a = utils_1.getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(element);
        (_b = utils_1.getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(element);
        this.elementInfos = this.elementInfos.filter((info) => info.element !== element);
    }
    handleAppVisibilityChanged() {
        const _super = Object.create(null, {
            handleAppVisibilityChanged: { get: () => super.handleAppVisibilityChanged }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.handleAppVisibilityChanged.call(this);
            if (!this.isAdaptiveStream)
                return;
            // on desktop don't pause when tab is backgrounded
            if (!utils_1.isMobile())
                return;
            this.updateVisibility();
        });
    }
    updateVisibility() {
        const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);
        const isVisible = this.elementInfos.some((info) => info.visible) && !this.isInBackground;
        if (this.lastVisible === isVisible) {
            return;
        }
        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
            // delay hidden events
            setTimeout(() => {
                this.updateVisibility();
            }, REACTION_DELAY);
            return;
        }
        this.lastVisible = isVisible;
        this.emit(events_1.TrackEvent.VisibilityChanged, isVisible, this);
    }
    updateDimensions() {
        var _a, _b, _c, _d;
        let maxWidth = 0;
        let maxHeight = 0;
        for (const info of this.elementInfos) {
            const pixelDensity = (_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity) !== null && _b !== void 0 ? _b : 1;
            const pixelDensityValue = pixelDensity === 'screen' ? window.devicePixelRatio : pixelDensity;
            const currentElementWidth = info.element.clientWidth * pixelDensityValue;
            const currentElementHeight = info.element.clientHeight * pixelDensityValue;
            if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {
                maxWidth = currentElementWidth;
                maxHeight = currentElementHeight;
            }
        }
        if (((_c = this.lastDimensions) === null || _c === void 0 ? void 0 : _c.width) === maxWidth && ((_d = this.lastDimensions) === null || _d === void 0 ? void 0 : _d.height) === maxHeight) {
            return;
        }
        this.lastDimensions = {
            width: maxWidth,
            height: maxHeight,
        };
        this.emit(events_1.TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
    }
}
exports.default = RemoteVideoTrack;
//# sourceMappingURL=RemoteVideoTrack.js.map