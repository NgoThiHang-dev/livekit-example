"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("../events");
const stats_1 = require("../stats");
const Track_1 = require("./Track");
class RemoteTrack extends Track_1.Track {
    constructor(mediaTrack, sid, kind, receiver) {
        super(mediaTrack, kind);
        this.streamState = Track_1.Track.StreamState.Active;
        this.sid = sid;
        this.receiver = receiver;
    }
    /** @internal */
    setMuted(muted) {
        if (this.isMuted !== muted) {
            this.isMuted = muted;
            this.emit(muted ? events_1.TrackEvent.Muted : events_1.TrackEvent.Unmuted, this);
        }
    }
    /** @internal */
    setMediaStream(stream) {
        // this is needed to determine when the track is finished
        // we send each track down in its own MediaStream, so we can assume the
        // current track is the only one that can be removed.
        this.mediaStream = stream;
        stream.onremovetrack = () => {
            this.receiver = undefined;
            this._currentBitrate = 0;
            this.emit(events_1.TrackEvent.Ended, this);
        };
    }
    start() {
        this.startMonitor();
        // use `enabled` of track to enable re-use of transceiver
        super.enable();
    }
    stop() {
        // use `enabled` of track to enable re-use of transceiver
        super.disable();
    }
    /* @internal */
    startMonitor() {
        setTimeout(() => {
            this.monitorReceiver();
        }, stats_1.monitorFrequency);
    }
}
exports.default = RemoteTrack;
//# sourceMappingURL=RemoteTrack.js.map