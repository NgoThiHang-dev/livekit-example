"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detachTrack = exports.attachToElement = exports.Track = void 0;
const events_1 = require("events");
const livekit_models_1 = require("../../proto/livekit_models");
const livekit_rtc_1 = require("../../proto/livekit_rtc");
const events_2 = require("../events");
const utils_1 = require("../utils");
// keep old audio elements when detached, we would re-use them since on iOS
// Safari tracks which audio elements have been "blessed" by the user.
const recycledElements = [];
class Track extends events_1.EventEmitter {
    constructor(mediaTrack, kind) {
        super();
        this.attachedElements = [];
        this.isMuted = false;
        this._currentBitrate = 0;
        this.appVisibilityChangedListener = () => {
            this.handleAppVisibilityChanged();
        };
        this.kind = kind;
        this.mediaStreamTrack = mediaTrack;
        this.source = Track.Source.Unknown;
        if (utils_1.isWeb()) {
            this.isInBackground = document.visibilityState === 'hidden';
            document.addEventListener('visibilitychange', this.appVisibilityChangedListener);
        }
        else {
            this.isInBackground = false;
        }
    }
    /** current receive bits per second */
    get currentBitrate() {
        return this._currentBitrate;
    }
    attach(element) {
        let elementType = 'audio';
        if (this.kind === Track.Kind.Video) {
            elementType = 'video';
        }
        if (!element) {
            if (elementType === 'audio') {
                recycledElements.forEach((e) => {
                    if (e.parentElement === null && !element) {
                        element = e;
                    }
                });
                if (element) {
                    // remove it from pool
                    recycledElements.splice(recycledElements.indexOf(element), 1);
                }
            }
            if (!element) {
                element = document.createElement(elementType);
            }
        }
        if (!this.attachedElements.includes(element)) {
            this.attachedElements.push(element);
        }
        // even if we believe it's already attached to the element, it's possible
        // the element's srcObject was set to something else out of band.
        // we'll want to re-attach it in that case
        attachToElement(this.mediaStreamTrack, element);
        if (element instanceof HTMLAudioElement) {
            // manually play audio to detect audio playback status
            element.play()
                .then(() => {
                this.emit(events_2.TrackEvent.AudioPlaybackStarted);
            })
                .catch((e) => {
                this.emit(events_2.TrackEvent.AudioPlaybackFailed, e);
            });
        }
        return element;
    }
    detach(element) {
        // detach from a single element
        if (element) {
            detachTrack(this.mediaStreamTrack, element);
            const idx = this.attachedElements.indexOf(element);
            if (idx >= 0) {
                this.attachedElements.splice(idx, 1);
                this.recycleElement(element);
            }
            return element;
        }
        const detached = [];
        this.attachedElements.forEach((elm) => {
            detachTrack(this.mediaStreamTrack, elm);
            detached.push(elm);
            this.recycleElement(elm);
        });
        // remove all tracks
        this.attachedElements = [];
        return detached;
    }
    stop() {
        this.mediaStreamTrack.stop();
        if (utils_1.isWeb()) {
            document.removeEventListener('visibilitychange', this.appVisibilityChangedListener);
        }
    }
    enable() {
        this.mediaStreamTrack.enabled = true;
    }
    disable() {
        this.mediaStreamTrack.enabled = false;
    }
    recycleElement(element) {
        if (element instanceof HTMLAudioElement) {
            // we only need to re-use a single element
            let shouldCache = true;
            element.pause();
            recycledElements.forEach((e) => {
                if (!e.parentElement) {
                    shouldCache = false;
                }
            });
            if (shouldCache) {
                recycledElements.push(element);
            }
        }
    }
    handleAppVisibilityChanged() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isInBackground = document.visibilityState === 'hidden';
        });
    }
}
exports.Track = Track;
/** @internal */
function attachToElement(track, element) {
    let mediaStream;
    if (element.srcObject instanceof MediaStream) {
        mediaStream = element.srcObject;
    }
    else {
        mediaStream = new MediaStream();
    }
    // check if track matches existing track
    let existingTracks;
    if (track.kind === 'audio') {
        existingTracks = mediaStream.getAudioTracks();
    }
    else {
        existingTracks = mediaStream.getVideoTracks();
    }
    if (!existingTracks.includes(track)) {
        existingTracks.forEach((et) => {
            mediaStream.removeTrack(et);
        });
        mediaStream.addTrack(track);
    }
    // avoid flicker
    if (element.srcObject !== mediaStream) {
        element.srcObject = mediaStream;
        if ((utils_1.isSafari() || utils_1.isFireFox()) && element instanceof HTMLVideoElement) {
            // Firefox also has a timing issue where video doesn't actually get attached unless
            // performed out-of-band
            // Safari 15 has a bug where in certain layouts, video element renders
            // black until the page is resized or other changes take place.
            // Resetting the src triggers it to render.
            // https://developer.apple.com/forums/thread/690523
            setTimeout(() => {
                element.srcObject = mediaStream;
            }, 0);
        }
    }
    element.autoplay = true;
    if (element instanceof HTMLVideoElement) {
        element.playsInline = true;
    }
}
exports.attachToElement = attachToElement;
/** @internal */
function detachTrack(track, element) {
    if (element.srcObject instanceof MediaStream) {
        const mediaStream = element.srcObject;
        mediaStream.removeTrack(track);
        element.srcObject = null;
    }
}
exports.detachTrack = detachTrack;
(function (Track) {
    let Kind;
    (function (Kind) {
        Kind["Audio"] = "audio";
        Kind["Video"] = "video";
        Kind["Unknown"] = "unknown";
    })(Kind = Track.Kind || (Track.Kind = {}));
    let Source;
    (function (Source) {
        Source["Camera"] = "camera";
        Source["Microphone"] = "microphone";
        Source["ScreenShare"] = "screen_share";
        Source["ScreenShareAudio"] = "screen_share_audio";
        Source["Unknown"] = "unknown";
    })(Source = Track.Source || (Track.Source = {}));
    let StreamState;
    (function (StreamState) {
        StreamState["Active"] = "active";
        StreamState["Paused"] = "paused";
        StreamState["Unknown"] = "unknown";
    })(StreamState = Track.StreamState || (Track.StreamState = {}));
    /** @internal */
    function kindToProto(k) {
        switch (k) {
            case Kind.Audio:
                return livekit_models_1.TrackType.AUDIO;
            case Kind.Video:
                return livekit_models_1.TrackType.VIDEO;
            default:
                return livekit_models_1.TrackType.UNRECOGNIZED;
        }
    }
    Track.kindToProto = kindToProto;
    /** @internal */
    function kindFromProto(t) {
        switch (t) {
            case livekit_models_1.TrackType.AUDIO:
                return Kind.Audio;
            case livekit_models_1.TrackType.VIDEO:
                return Kind.Video;
            default:
                return Kind.Unknown;
        }
    }
    Track.kindFromProto = kindFromProto;
    /** @internal */
    function sourceToProto(s) {
        switch (s) {
            case Source.Camera:
                return livekit_models_1.TrackSource.CAMERA;
            case Source.Microphone:
                return livekit_models_1.TrackSource.MICROPHONE;
            case Source.ScreenShare:
                return livekit_models_1.TrackSource.SCREEN_SHARE;
            case Source.ScreenShareAudio:
                return livekit_models_1.TrackSource.SCREEN_SHARE_AUDIO;
            default:
                return livekit_models_1.TrackSource.UNRECOGNIZED;
        }
    }
    Track.sourceToProto = sourceToProto;
    /** @internal */
    function sourceFromProto(s) {
        switch (s) {
            case livekit_models_1.TrackSource.CAMERA:
                return Source.Camera;
            case livekit_models_1.TrackSource.MICROPHONE:
                return Source.Microphone;
            case livekit_models_1.TrackSource.SCREEN_SHARE:
                return Source.ScreenShare;
            case livekit_models_1.TrackSource.SCREEN_SHARE_AUDIO:
                return Source.ScreenShareAudio;
            default:
                return Source.Unknown;
        }
    }
    Track.sourceFromProto = sourceFromProto;
    /** @internal */
    function streamStateFromProto(s) {
        switch (s) {
            case livekit_rtc_1.StreamState.ACTIVE:
                return StreamState.Active;
            case livekit_rtc_1.StreamState.PAUSED:
                return StreamState.Paused;
            default:
                return StreamState.Unknown;
        }
    }
    Track.streamStateFromProto = streamStateFromProto;
})(Track = exports.Track || (exports.Track = {}));
//# sourceMappingURL=Track.js.map