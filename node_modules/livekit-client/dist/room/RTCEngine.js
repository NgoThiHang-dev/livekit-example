"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.maxICEConnectTimeout = void 0;
const events_1 = require("events");
const SignalClient_1 = require("../api/SignalClient");
const logger_1 = __importDefault(require("../logger"));
const livekit_models_1 = require("../proto/livekit_models");
const livekit_rtc_1 = require("../proto/livekit_rtc");
const errors_1 = require("./errors");
const events_2 = require("./events");
const PCTransport_1 = __importDefault(require("./PCTransport"));
const utils_1 = require("./utils");
const lossyDataChannel = '_lossy';
const reliableDataChannel = '_reliable';
const maxReconnectRetries = 10;
const minReconnectWait = 1 * 1000;
const maxReconnectDuration = 60 * 1000;
exports.maxICEConnectTimeout = 15 * 1000;
/** @internal */
class RTCEngine extends events_1.EventEmitter {
    constructor() {
        super();
        this.rtcConfig = {};
        this.subscriberPrimary = false;
        this.pcConnected = false;
        this.isClosed = true;
        this.pendingTrackResolvers = {};
        // true if publisher connection has already been established.
        // this is helpful to know if we need to restart ICE on the publisher connection
        this.hasPublished = false;
        this.reconnectAttempts = 0;
        this.reconnectStart = 0;
        this.fullReconnectOnNext = false;
        this.handleDataChannel = ({ channel }) => __awaiter(this, void 0, void 0, function* () {
            if (!channel) {
                return;
            }
            if (channel.label === reliableDataChannel) {
                this.reliableDCSub = channel;
            }
            else if (channel.label === lossyDataChannel) {
                this.lossyDCSub = channel;
            }
            else {
                return;
            }
            channel.onmessage = this.handleDataMessage;
        });
        this.handleDataMessage = (message) => __awaiter(this, void 0, void 0, function* () {
            // decode
            let buffer;
            if (message.data instanceof ArrayBuffer) {
                buffer = message.data;
            }
            else if (message.data instanceof Blob) {
                buffer = yield message.data.arrayBuffer();
            }
            else {
                logger_1.default.error('unsupported data type', message.data);
                return;
            }
            const dp = livekit_models_1.DataPacket.decode(new Uint8Array(buffer));
            if (dp.speaker) {
                // dispatch speaker updates
                this.emit(events_2.EngineEvent.ActiveSpeakersUpdate, dp.speaker.speakers);
            }
            else if (dp.user) {
                this.emit(events_2.EngineEvent.DataPacketReceived, dp.user, dp.kind);
            }
        });
        this.handleDataError = (event) => {
            const channel = event.currentTarget;
            const channelKind = channel.maxRetransmits === 0 ? 'lossy' : 'reliable';
            if (event instanceof ErrorEvent) {
                const { error } = event.error;
                logger_1.default.error(`DataChannel error on ${channelKind}: ${event.message}`, error);
            }
            else {
                logger_1.default.error(`Unknown DataChannel Error on ${channelKind}`, event);
            }
        };
        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection
        // continues to work, we can reconnect to websocket to continue the session
        // after a number of retries, we'll close and give up permanently
        this.handleDisconnect = (connection) => {
            if (this.isClosed) {
                return;
            }
            logger_1.default.debug(`${connection} disconnected`);
            if (this.reconnectAttempts === 0) {
                // only reset start time on the first try
                this.reconnectStart = Date.now();
            }
            const delay = (this.reconnectAttempts * this.reconnectAttempts) * 300;
            setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (this.isClosed) {
                    return;
                }
                if (utils_1.isFireFox() // TODO remove once clientConfiguration handles firefox case server side
                    || ((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === livekit_models_1.ClientConfigSetting.DISABLED) {
                    this.fullReconnectOnNext = true;
                }
                try {
                    if (this.fullReconnectOnNext) {
                        yield this.restartConnection();
                    }
                    else {
                        yield this.resumeConnection();
                    }
                    this.reconnectAttempts = 0;
                    this.fullReconnectOnNext = false;
                }
                catch (e) {
                    this.reconnectAttempts += 1;
                    let recoverable = true;
                    if (e instanceof errors_1.UnexpectedConnectionState) {
                        logger_1.default.debug('received unrecoverable error', e.message);
                        // unrecoverable
                        recoverable = false;
                    }
                    else if (!(e instanceof SignalReconnectError)) {
                        // cannot resume
                        this.fullReconnectOnNext = true;
                    }
                    const duration = Date.now() - this.reconnectStart;
                    if (this.reconnectAttempts >= maxReconnectRetries || duration > maxReconnectDuration) {
                        recoverable = false;
                    }
                    if (recoverable) {
                        this.handleDisconnect('reconnect');
                    }
                    else {
                        logger_1.default.info(`could not recover connection after ${maxReconnectRetries} attempts, ${duration}ms. giving up`);
                        this.emit(events_2.EngineEvent.Disconnected);
                        this.close();
                    }
                }
            }), delay);
        };
        this.client = new SignalClient_1.SignalClient();
    }
    join(url, token, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            this.url = url;
            this.token = token;
            this.signalOpts = opts;
            const joinResponse = yield this.client.join(url, token, opts);
            this.isClosed = false;
            this.subscriberPrimary = joinResponse.subscriberPrimary;
            if (!this.publisher) {
                this.configure(joinResponse);
            }
            // create offer
            if (!this.subscriberPrimary) {
                this.negotiate();
            }
            this.clientConfiguration = joinResponse.clientConfiguration;
            return joinResponse;
        });
    }
    close() {
        this.isClosed = true;
        this.removeAllListeners();
        if (this.publisher && this.publisher.pc.signalingState !== 'closed') {
            this.publisher.pc.getSenders().forEach((sender) => {
                var _a, _b;
                try {
                    // TODO: react-native-webrtc doesn't have removeTrack yet.
                    if ((_a = this.publisher) === null || _a === void 0 ? void 0 : _a.pc.removeTrack) {
                        (_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.removeTrack(sender);
                    }
                }
                catch (e) {
                    logger_1.default.warn('could not removeTrack', e);
                }
            });
            this.publisher.close();
            this.publisher = undefined;
        }
        if (this.subscriber) {
            this.subscriber.close();
            this.subscriber = undefined;
        }
        this.client.close();
    }
    addTrack(req) {
        if (this.pendingTrackResolvers[req.cid]) {
            throw new errors_1.TrackInvalidError('a track with the same ID has already been published');
        }
        return new Promise((resolve) => {
            this.pendingTrackResolvers[req.cid] = resolve;
            this.client.sendAddTrack(req);
        });
    }
    updateMuteStatus(trackSid, muted) {
        this.client.sendMuteTrack(trackSid, muted);
    }
    get dataSubscriberReadyState() {
        var _a;
        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;
    }
    get connectedServerAddress() {
        return this.connectedServerAddr;
    }
    configure(joinResponse) {
        // already configured
        if (this.publisher || this.subscriber) {
            return;
        }
        // update ICE servers before creating PeerConnection
        if (joinResponse.iceServers && !this.rtcConfig.iceServers) {
            const rtcIceServers = [];
            joinResponse.iceServers.forEach((iceServer) => {
                const rtcIceServer = {
                    urls: iceServer.urls,
                };
                if (iceServer.username)
                    rtcIceServer.username = iceServer.username;
                if (iceServer.credential) {
                    rtcIceServer.credential = iceServer.credential;
                }
                rtcIceServers.push(rtcIceServer);
            });
            this.rtcConfig.iceServers = rtcIceServers;
        }
        // @ts-ignore
        this.rtcConfig.sdpSemantics = 'unified-plan';
        // @ts-ignore
        this.rtcConfig.continualGatheringPolicy = 'gather_continually';
        this.publisher = new PCTransport_1.default(this.rtcConfig);
        this.subscriber = new PCTransport_1.default(this.rtcConfig);
        this.emit(events_2.EngineEvent.TransportsCreated, this.publisher, this.subscriber);
        this.publisher.pc.onicecandidate = (ev) => {
            if (!ev.candidate)
                return;
            logger_1.default.trace('adding ICE candidate for peer', ev.candidate);
            this.client.sendIceCandidate(ev.candidate, livekit_rtc_1.SignalTarget.PUBLISHER);
        };
        this.subscriber.pc.onicecandidate = (ev) => {
            if (!ev.candidate)
                return;
            this.client.sendIceCandidate(ev.candidate, livekit_rtc_1.SignalTarget.SUBSCRIBER);
        };
        this.publisher.onOffer = (offer) => {
            this.client.sendOffer(offer);
        };
        let primaryPC = this.publisher.pc;
        if (joinResponse.subscriberPrimary) {
            primaryPC = this.subscriber.pc;
            // in subscriber primary mode, server side opens sub data channels.
            this.subscriber.pc.ondatachannel = this.handleDataChannel;
        }
        this.primaryPC = primaryPC;
        primaryPC.onconnectionstatechange = () => __awaiter(this, void 0, void 0, function* () {
            if (primaryPC.connectionState === 'connected') {
                logger_1.default.trace('pc connected');
                try {
                    this.connectedServerAddr = yield getConnectedAddress(primaryPC);
                }
                catch (e) {
                    logger_1.default.warn('could not get connected server address', e);
                }
                if (!this.pcConnected) {
                    this.pcConnected = true;
                    this.emit(events_2.EngineEvent.Connected);
                }
            }
            else if (primaryPC.connectionState === 'failed') {
                // on Safari, PeerConnection will switch to 'disconnected' during renegotiation
                logger_1.default.trace('pc disconnected');
                if (this.pcConnected) {
                    this.pcConnected = false;
                    this.handleDisconnect('peerconnection');
                }
            }
        });
        if (utils_1.isWeb()) {
            this.subscriber.pc.ontrack = (ev) => {
                this.emit(events_2.EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
            };
        }
        else {
            // TODO: react-native-webrtc doesn't have ontrack yet, replace when ready.
            // @ts-ignore
            this.subscriber.pc.onaddstream = (ev) => {
                const track = ev.stream.getTracks()[0];
                this.emit(events_2.EngineEvent.MediaTrackAdded, track, ev.stream);
            };
        }
        // data channels
        this.lossyDC = this.publisher.pc.createDataChannel(lossyDataChannel, {
            // will drop older packets that arrive
            ordered: true,
            maxRetransmits: 0,
        });
        this.reliableDC = this.publisher.pc.createDataChannel(reliableDataChannel, {
            ordered: true,
        });
        // also handle messages over the pub channel, for backwards compatibility
        this.lossyDC.onmessage = this.handleDataMessage;
        this.reliableDC.onmessage = this.handleDataMessage;
        // handle datachannel errors
        this.lossyDC.onerror = this.handleDataError;
        this.reliableDC.onerror = this.handleDataError;
        // configure signaling client
        this.client.onAnswer = (sd) => __awaiter(this, void 0, void 0, function* () {
            if (!this.publisher) {
                return;
            }
            logger_1.default.debug('received server answer', sd.type, this.publisher.pc.signalingState);
            yield this.publisher.setRemoteDescription(sd);
        });
        // add candidate on trickle
        this.client.onTrickle = (candidate, target) => {
            if (!this.publisher || !this.subscriber) {
                return;
            }
            logger_1.default.trace('got ICE candidate from peer', candidate, target);
            if (target === livekit_rtc_1.SignalTarget.PUBLISHER) {
                this.publisher.addIceCandidate(candidate);
            }
            else {
                this.subscriber.addIceCandidate(candidate);
            }
        };
        // when server creates an offer for the client
        this.client.onOffer = (sd) => __awaiter(this, void 0, void 0, function* () {
            if (!this.subscriber) {
                return;
            }
            logger_1.default.debug('received server offer', sd.type, this.subscriber.pc.signalingState);
            yield this.subscriber.setRemoteDescription(sd);
            // answer the offer
            const answer = yield this.subscriber.pc.createAnswer();
            yield this.subscriber.pc.setLocalDescription(answer);
            this.client.sendAnswer(answer);
        });
        this.client.onLocalTrackPublished = (res) => {
            logger_1.default.debug('received trackPublishedResponse', res);
            const resolve = this.pendingTrackResolvers[res.cid];
            if (!resolve) {
                logger_1.default.error('missing track resolver for ', res.cid);
                return;
            }
            delete this.pendingTrackResolvers[res.cid];
            resolve(res.track);
        };
        this.client.onTokenRefresh = (token) => {
            this.token = token;
        };
        this.client.onClose = () => {
            this.handleDisconnect('signal');
        };
        this.client.onLeave = (leave) => {
            if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {
                this.fullReconnectOnNext = true;
                this.primaryPC = undefined;
            }
            else {
                this.emit(events_2.EngineEvent.Disconnected);
                this.close();
            }
        };
    }
    restartConnection() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.url || !this.token) {
                // permanent failure, don't attempt reconnection
                throw new errors_1.UnexpectedConnectionState('could not reconnect, url or token not saved');
            }
            logger_1.default.info('reconnecting, attempt', this.reconnectAttempts);
            if (this.reconnectAttempts === 0) {
                this.emit(events_2.EngineEvent.Restarting);
            }
            this.primaryPC = undefined;
            (_a = this.publisher) === null || _a === void 0 ? void 0 : _a.close();
            this.publisher = undefined;
            (_b = this.subscriber) === null || _b === void 0 ? void 0 : _b.close();
            this.subscriber = undefined;
            let joinResponse;
            try {
                joinResponse = yield this.join(this.url, this.token, this.signalOpts);
            }
            catch (e) {
                throw new SignalReconnectError();
            }
            yield this.waitForPCConnected();
            this.client.setReconnected();
            // reconnect success
            this.emit(events_2.EngineEvent.Restarted, joinResponse);
        });
    }
    resumeConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.url || !this.token) {
                // permanent failure, don't attempt reconnection
                throw new errors_1.UnexpectedConnectionState('could not reconnect, url or token not saved');
            }
            // trigger publisher reconnect
            if (!this.publisher || !this.subscriber) {
                throw new errors_1.UnexpectedConnectionState('publisher and subscriber connections unset');
            }
            logger_1.default.info('resuming signal connection, attempt', this.reconnectAttempts);
            if (this.reconnectAttempts === 0) {
                this.emit(events_2.EngineEvent.Resuming);
            }
            try {
                yield this.client.reconnect(this.url, this.token);
            }
            catch (e) {
                throw new SignalReconnectError();
            }
            this.emit(events_2.EngineEvent.SignalResumed);
            this.subscriber.restartingIce = true;
            // only restart publisher if it's needed
            if (this.hasPublished) {
                yield this.publisher.createAndSendOffer({ iceRestart: true });
            }
            yield this.waitForPCConnected();
            this.client.setReconnected();
            // resume success
            this.emit(events_2.EngineEvent.Resumed);
        });
    }
    waitForPCConnected() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const startTime = (new Date()).getTime();
            let now = startTime;
            this.pcConnected = false;
            while (now - startTime < exports.maxICEConnectTimeout) {
                // if there is no connectionstatechange callback fired
                // check connectionstate after minReconnectWait
                if (this.primaryPC === undefined) {
                    // we can abort early, connection is hosed
                    break;
                }
                else if (now - startTime > minReconnectWait && ((_a = this.primaryPC) === null || _a === void 0 ? void 0 : _a.connectionState) === 'connected') {
                    this.pcConnected = true;
                }
                if (this.pcConnected) {
                    return;
                }
                yield utils_1.sleep(100);
                now = (new Date()).getTime();
            }
            // have not reconnected, throw
            throw new errors_1.ConnectionError('could not establish PC connection');
        });
    }
    /* @internal */
    sendDataPacket(packet, kind) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = livekit_models_1.DataPacket.encode(packet).finish();
            // make sure we do have a data connection
            yield this.ensurePublisherConnected(kind);
            if (kind === livekit_models_1.DataPacket_Kind.LOSSY && this.lossyDC) {
                this.lossyDC.send(msg);
            }
            else if (kind === livekit_models_1.DataPacket_Kind.RELIABLE && this.reliableDC) {
                this.reliableDC.send(msg);
            }
        });
    }
    ensurePublisherConnected(kind) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.subscriberPrimary) {
                return;
            }
            if (!this.publisher) {
                throw new errors_1.ConnectionError('publisher connection not set');
            }
            if (!this.publisher.isICEConnected && this.publisher.pc.iceConnectionState !== 'checking') {
                // start negotiation
                this.negotiate();
            }
            const targetChannel = this.dataChannelForKind(kind);
            if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === 'open') {
                return;
            }
            // wait until publisher ICE connected
            const endTime = (new Date()).getTime() + exports.maxICEConnectTimeout;
            while ((new Date()).getTime() < endTime) {
                if (this.publisher.isICEConnected && ((_a = this.dataChannelForKind(kind)) === null || _a === void 0 ? void 0 : _a.readyState) === 'open') {
                    return;
                }
                yield utils_1.sleep(50);
            }
            throw new errors_1.ConnectionError(`could not establish publisher connection, state ${(_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.iceConnectionState}`);
        });
    }
    /** @internal */
    negotiate() {
        if (!this.publisher) {
            return;
        }
        this.hasPublished = true;
        this.publisher.negotiate();
    }
    dataChannelForKind(kind) {
        if (kind === livekit_models_1.DataPacket_Kind.LOSSY) {
            return this.lossyDC;
        }
        if (kind === livekit_models_1.DataPacket_Kind.RELIABLE) {
            return this.reliableDC;
        }
    }
}
exports.default = RTCEngine;
function getConnectedAddress(pc) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let selectedCandidatePairId = '';
        const candidatePairs = new Map();
        // id -> candidate ip
        const candidates = new Map();
        const stats = yield pc.getStats();
        stats.forEach((v) => {
            switch (v.type) {
                case 'transport':
                    selectedCandidatePairId = v.selectedCandidatePairId;
                    break;
                case 'candidate-pair':
                    if (selectedCandidatePairId === '' && v.selected) {
                        selectedCandidatePairId = v.id;
                    }
                    candidatePairs.set(v.id, v);
                    break;
                case 'remote-candidate':
                    candidates.set(v.id, `${v.address}:${v.port}`);
                    break;
                default:
            }
        });
        if (selectedCandidatePairId === '') {
            return undefined;
        }
        const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;
        if (selectedID === undefined) {
            return undefined;
        }
        return candidates.get(selectedID);
    });
}
class SignalReconnectError extends Error {
}
//# sourceMappingURL=RTCEngine.js.map