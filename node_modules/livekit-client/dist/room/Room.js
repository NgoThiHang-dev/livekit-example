"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoomState = void 0;
const events_1 = require("events");
const SignalClient_1 = require("../api/SignalClient");
const logger_1 = __importDefault(require("../logger"));
const livekit_models_1 = require("../proto/livekit_models");
const livekit_rtc_1 = require("../proto/livekit_rtc");
const DeviceManager_1 = __importDefault(require("./DeviceManager"));
const errors_1 = require("./errors");
const events_2 = require("./events");
const LocalParticipant_1 = __importDefault(require("./participant/LocalParticipant"));
const RemoteParticipant_1 = __importDefault(require("./participant/RemoteParticipant"));
const RTCEngine_1 = __importStar(require("./RTCEngine"));
const defaults_1 = require("./track/defaults");
const RemoteTrackPublication_1 = __importDefault(require("./track/RemoteTrackPublication"));
const Track_1 = require("./track/Track");
const utils_1 = require("./track/utils");
const utils_2 = require("./utils");
var RoomState;
(function (RoomState) {
    RoomState["Disconnected"] = "disconnected";
    RoomState["Connected"] = "connected";
    RoomState["Reconnecting"] = "reconnecting";
})(RoomState = exports.RoomState || (exports.RoomState = {}));
/**
 * In LiveKit, a room is the logical grouping for a list of participants.
 * Participants in a room can publish tracks, and subscribe to others' tracks.
 *
 * a Room fires [[RoomEvent | RoomEvents]].
 *
 * @noInheritDoc
 */
class Room extends events_1.EventEmitter {
    /**
     * Creates a new Room, the primary construct for a LiveKit session.
     * @param options
     */
    constructor(options) {
        super();
        this.state = RoomState.Disconnected;
        /**
         * list of participants that are actively speaking. when this changes
         * a [[RoomEvent.ActiveSpeakersChanged]] event is fired
         */
        this.activeSpeakers = [];
        // available after connected
        /** server assigned unique room id */
        this.sid = '';
        /** user assigned name, derived from JWT token */
        this.name = '';
        /** room metadata */
        this.metadata = undefined;
        this.audioEnabled = true;
        this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {
            // guard against calling connect
            if (this.state !== RoomState.Disconnected) {
                logger_1.default.warn('already connected to room', this.name);
                return;
            }
            // recreate engine if previously disconnected
            this.createEngine();
            this.acquireAudioContext();
            if (opts === null || opts === void 0 ? void 0 : opts.rtcConfig) {
                this.engine.rtcConfig = opts.rtcConfig;
            }
            this.connOptions = opts;
            try {
                const joinResponse = yield this.engine.join(url, token, opts);
                logger_1.default.debug(`connected to Livekit Server version: ${joinResponse.serverVersion}, region: ${joinResponse.serverRegion}`);
                if (!joinResponse.serverVersion) {
                    throw new errors_1.UnsupportedServer('unknown server version');
                }
                if (joinResponse.serverVersion === '0.15.1' && this.options.dynacast) {
                    logger_1.default.debug('disabling dynacast due to server version');
                    // dynacast has a bug in 0.15.1, so we cannot use it then
                    this.options.dynacast = false;
                }
                this.state = RoomState.Connected;
                this.emit(events_2.RoomEvent.StateChanged, this.state);
                const pi = joinResponse.participant;
                this.localParticipant.sid = pi.sid;
                this.localParticipant.identity = pi.identity;
                this.localParticipant.updateInfo(pi);
                // forward metadata changed for the local participant
                this.localParticipant
                    .on(events_2.ParticipantEvent.MetadataChanged, (metadata) => {
                    this.emit(events_2.RoomEvent.MetadataChanged, metadata, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
                    this.emit(events_2.RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.TrackMuted, (pub) => {
                    this.emit(events_2.RoomEvent.TrackMuted, pub, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.TrackUnmuted, (pub) => {
                    this.emit(events_2.RoomEvent.TrackUnmuted, pub, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.LocalTrackPublished, (pub) => {
                    this.emit(events_2.RoomEvent.LocalTrackPublished, pub, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.LocalTrackUnpublished, (pub) => {
                    this.emit(events_2.RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.ConnectionQualityChanged, (quality) => {
                    this.emit(events_2.RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);
                })
                    .on(events_2.ParticipantEvent.MediaDevicesError, (e) => {
                    this.emit(events_2.RoomEvent.MediaDevicesError, e);
                })
                    .on(events_2.ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {
                    this.emit(events_2.RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);
                });
                // populate remote participants, these should not trigger new events
                joinResponse.otherParticipants.forEach((info) => {
                    this.getOrCreateParticipant(info.sid, info);
                });
                this.name = joinResponse.room.name;
                this.sid = joinResponse.room.sid;
                this.metadata = joinResponse.room.metadata;
            }
            catch (err) {
                this.engine.close();
                throw err;
            }
            // don't return until ICE connected
            return new Promise((resolve, reject) => {
                const connectTimeout = setTimeout(() => {
                    // timeout
                    this.engine.close();
                    reject(new errors_1.ConnectionError('could not connect after timeout'));
                }, RTCEngine_1.maxICEConnectTimeout);
                this.engine.once(events_2.EngineEvent.Connected, () => {
                    clearTimeout(connectTimeout);
                    // also hook unload event
                    if (utils_2.isWeb()) {
                        window.addEventListener('beforeunload', this.onBeforeUnload);
                        navigator.mediaDevices.addEventListener('devicechange', this.handleDeviceChange);
                    }
                    resolve(this);
                });
            });
        });
        /**
         * disconnects the room, emits [[RoomEvent.Disconnected]]
         */
        this.disconnect = (stopTracks = true) => {
            // send leave
            if (this.engine) {
                this.engine.client.sendLeave();
                this.engine.close();
            }
            this.handleDisconnect(stopTracks);
            /* @ts-ignore */
            this.engine = undefined;
        };
        this.onBeforeUnload = () => {
            this.disconnect();
        };
        this.handleRestarting = () => {
            this.state = RoomState.Reconnecting;
            this.emit(events_2.RoomEvent.Reconnecting);
            this.emit(events_2.RoomEvent.StateChanged, this.state);
            // also unwind existing participants & existing subscriptions
            for (const p of this.participants.values()) {
                this.handleParticipantDisconnected(p.sid, p);
            }
        };
        this.handleRestarted = (joinResponse) => __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug('reconnected to server region', joinResponse.serverRegion);
            this.state = RoomState.Connected;
            this.emit(events_2.RoomEvent.Reconnected);
            this.emit(events_2.RoomEvent.StateChanged, this.state);
            // rehydrate participants
            if (joinResponse.participant) {
                // with a restart, the sid will have changed, we'll map our understanding to it
                this.localParticipant.sid = joinResponse.participant.sid;
                this.handleParticipantUpdates([joinResponse.participant]);
            }
            this.handleParticipantUpdates(joinResponse.otherParticipants);
            // unpublish & republish tracks
            const localPubs = [];
            this.localParticipant.tracks.forEach((pub) => {
                if (pub.track) {
                    localPubs.push(pub);
                }
            });
            yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {
                const track = pub.track;
                this.localParticipant.unpublishTrack(track, false);
                this.localParticipant.publishTrack(track, pub.options);
            })));
        });
        this.handleParticipantUpdates = (participantInfos) => {
            // handle changes to participant state, and send events
            participantInfos.forEach((info) => {
                if (info.sid === this.localParticipant.sid
                    || info.identity === this.localParticipant.identity) {
                    this.localParticipant.updateInfo(info);
                    return;
                }
                let remoteParticipant = this.participants.get(info.sid);
                const isNewParticipant = !remoteParticipant;
                // create participant if doesn't exist
                remoteParticipant = this.getOrCreateParticipant(info.sid, info);
                // when it's disconnected, send updates
                if (info.state === livekit_models_1.ParticipantInfo_State.DISCONNECTED) {
                    this.handleParticipantDisconnected(info.sid, remoteParticipant);
                }
                else if (isNewParticipant) {
                    // fire connected event
                    this.emit(events_2.RoomEvent.ParticipantConnected, remoteParticipant);
                }
                else {
                    // just update, no events
                    remoteParticipant.updateInfo(info);
                }
            });
        };
        // updates are sent only when there's a change to speaker ordering
        this.handleActiveSpeakersUpdate = (speakers) => {
            const activeSpeakers = [];
            const seenSids = {};
            speakers.forEach((speaker) => {
                seenSids[speaker.sid] = true;
                if (speaker.sid === this.localParticipant.sid) {
                    this.localParticipant.audioLevel = speaker.level;
                    this.localParticipant.setIsSpeaking(true);
                    activeSpeakers.push(this.localParticipant);
                }
                else {
                    const p = this.participants.get(speaker.sid);
                    if (p) {
                        p.audioLevel = speaker.level;
                        p.setIsSpeaking(true);
                        activeSpeakers.push(p);
                    }
                }
            });
            if (!seenSids[this.localParticipant.sid]) {
                this.localParticipant.audioLevel = 0;
                this.localParticipant.setIsSpeaking(false);
            }
            this.participants.forEach((p) => {
                if (!seenSids[p.sid]) {
                    p.audioLevel = 0;
                    p.setIsSpeaking(false);
                }
            });
            this.activeSpeakers = activeSpeakers;
            this.emit(events_2.RoomEvent.ActiveSpeakersChanged, activeSpeakers);
        };
        // process list of changed speakers
        this.handleSpeakersChanged = (speakerUpdates) => {
            const lastSpeakers = new Map();
            this.activeSpeakers.forEach((p) => {
                lastSpeakers.set(p.sid, p);
            });
            speakerUpdates.forEach((speaker) => {
                let p = this.participants.get(speaker.sid);
                if (speaker.sid === this.localParticipant.sid) {
                    p = this.localParticipant;
                }
                if (!p) {
                    return;
                }
                p.audioLevel = speaker.level;
                p.setIsSpeaking(speaker.active);
                if (speaker.active) {
                    lastSpeakers.set(speaker.sid, p);
                }
                else {
                    lastSpeakers.delete(speaker.sid);
                }
            });
            const activeSpeakers = Array.from(lastSpeakers.values());
            activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);
            this.activeSpeakers = activeSpeakers;
            this.emit(events_2.RoomEvent.ActiveSpeakersChanged, activeSpeakers);
        };
        this.handleStreamStateUpdate = (streamStateUpdate) => {
            streamStateUpdate.streamStates.forEach((streamState) => {
                const participant = this.participants.get(streamState.participantSid);
                if (!participant) {
                    return;
                }
                const pub = participant.getTrackPublication(streamState.trackSid);
                if (!pub || !pub.track) {
                    return;
                }
                pub.track.streamState = Track_1.Track.streamStateFromProto(streamState.state);
                participant.emit(events_2.ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
                this.emit(events_2.ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);
            });
        };
        this.handleSubscriptionPermissionUpdate = (update) => {
            const participant = this.participants.get(update.participantSid);
            if (!participant) {
                return;
            }
            const pub = participant.getTrackPublication(update.trackSid);
            if (!pub) {
                return;
            }
            pub._allowed = update.allowed;
            participant.emit(events_2.ParticipantEvent.TrackSubscriptionPermissionChanged, pub, pub.subscriptionStatus);
            this.emit(events_2.ParticipantEvent.TrackSubscriptionPermissionChanged, pub, pub.subscriptionStatus, participant);
        };
        this.handleDataPacket = (userPacket, kind) => {
            // find the participant
            const participant = this.participants.get(userPacket.participantSid);
            this.emit(events_2.RoomEvent.DataReceived, userPacket.payload, participant, kind);
            // also emit on the participant
            participant === null || participant === void 0 ? void 0 : participant.emit(events_2.ParticipantEvent.DataReceived, userPacket.payload, kind);
        };
        this.handleAudioPlaybackStarted = () => {
            if (this.canPlaybackAudio) {
                return;
            }
            this.audioEnabled = true;
            this.emit(events_2.RoomEvent.AudioPlaybackStatusChanged, true);
        };
        this.handleAudioPlaybackFailed = (e) => {
            logger_1.default.warn('could not playback audio', e);
            if (!this.canPlaybackAudio) {
                return;
            }
            this.audioEnabled = false;
            this.emit(events_2.RoomEvent.AudioPlaybackStatusChanged, false);
        };
        this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {
            this.emit(events_2.RoomEvent.MediaDevicesChanged);
        });
        this.handleRoomUpdate = (r) => {
            this.metadata = r.metadata;
            this.emit(events_2.RoomEvent.RoomMetadataChanged, r.metadata);
        };
        this.handleConnectionQualityUpdate = (update) => {
            update.updates.forEach((info) => {
                if (info.participantSid === this.localParticipant.sid) {
                    this.localParticipant.setConnectionQuality(info.quality);
                    return;
                }
                const participant = this.participants.get(info.participantSid);
                if (participant) {
                    participant.setConnectionQuality(info.quality);
                }
            });
        };
        this.participants = new Map();
        this.options = options || {};
        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, defaults_1.audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);
        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, defaults_1.videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);
        this.options.publishDefaults = Object.assign(Object.assign({}, defaults_1.publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);
        this.createEngine();
        this.localParticipant = new LocalParticipant_1.default('', '', this.engine, this.options);
    }
    createEngine() {
        if (this.engine) {
            return;
        }
        this.engine = new RTCEngine_1.default();
        this.engine.client.signalLatency = this.options.expSignalLatency;
        this.engine.client.onParticipantUpdate = this.handleParticipantUpdates;
        this.engine.client.onRoomUpdate = this.handleRoomUpdate;
        this.engine.client.onSpeakersChanged = this.handleSpeakersChanged;
        this.engine.client.onStreamStateUpdate = this.handleStreamStateUpdate;
        this.engine.client.onSubscriptionPermissionUpdate = this.handleSubscriptionPermissionUpdate;
        this.engine.client.onConnectionQuality = this.handleConnectionQualityUpdate;
        this.engine
            .on(events_2.EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {
            this.onTrackAdded(mediaTrack, stream, receiver);
        })
            .on(events_2.EngineEvent.Disconnected, () => {
            this.handleDisconnect();
        })
            .on(events_2.EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate)
            .on(events_2.EngineEvent.DataPacketReceived, this.handleDataPacket)
            .on(events_2.EngineEvent.Resuming, () => {
            this.state = RoomState.Reconnecting;
            this.emit(events_2.RoomEvent.Reconnecting);
            this.emit(events_2.RoomEvent.StateChanged, this.state);
        })
            .on(events_2.EngineEvent.Resumed, () => {
            this.state = RoomState.Connected;
            this.emit(events_2.RoomEvent.Reconnected);
            this.emit(events_2.RoomEvent.StateChanged, this.state);
            this.updateSubscriptions();
        })
            .on(events_2.EngineEvent.SignalResumed, () => {
            if (this.state === RoomState.Reconnecting) {
                this.sendSyncState();
            }
        })
            .on(events_2.EngineEvent.Restarting, this.handleRestarting)
            .on(events_2.EngineEvent.Restarted, this.handleRestarted);
    }
    /**
     * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
     * In particular, it handles Chrome's unique behavior of creating `default`
     * devices. When encountered, it'll be removed from the list of devices.
     * The actual default device will be placed at top.
     * @param kind
     * @returns a list of available local devices
     */
    static getLocalDevices(kind) {
        return DeviceManager_1.default.getInstance().getDevices(kind);
    }
    /**
     * retrieves a participant by identity
     * @param identity
     * @returns
     */
    getParticipantByIdentity(identity) {
        for (const [, p] of this.participants) {
            if (p.identity === identity) {
                return p;
            }
        }
        if (this.localParticipant.identity === identity) {
            return this.localParticipant;
        }
    }
    /**
     * @internal for testing
     */
    simulateScenario(scenario) {
        let req;
        switch (scenario) {
            case 'speaker':
                req = livekit_rtc_1.SimulateScenario.fromPartial({
                    speakerUpdate: 3,
                });
                break;
            case 'node-failure':
                req = livekit_rtc_1.SimulateScenario.fromPartial({
                    nodeFailure: true,
                });
                break;
            case 'server-leave':
                req = livekit_rtc_1.SimulateScenario.fromPartial({
                    serverLeave: true,
                });
                break;
            case 'migration':
                req = livekit_rtc_1.SimulateScenario.fromPartial({
                    migration: true,
                });
                break;
            default:
        }
        if (req) {
            this.engine.client.sendSimulateScenario(req);
        }
    }
    /**
     * Browsers have different policies regarding audio playback. Most requiring
     * some form of user interaction (click/tap/etc).
     * In those cases, audio will be silent until a click/tap triggering one of the following
     * - `startAudio`
     * - `getUserMedia`
     */
    startAudio() {
        return __awaiter(this, void 0, void 0, function* () {
            this.acquireAudioContext();
            const elements = [];
            this.participants.forEach((p) => {
                p.audioTracks.forEach((t) => {
                    if (t.track) {
                        t.track.attachedElements.forEach((e) => {
                            elements.push(e);
                        });
                    }
                });
            });
            try {
                yield Promise.all(elements.map((e) => e.play()));
                this.handleAudioPlaybackStarted();
            }
            catch (err) {
                this.handleAudioPlaybackFailed(err);
                throw err;
            }
        });
    }
    /**
     * Returns true if audio playback is enabled
     */
    get canPlaybackAudio() {
        return this.audioEnabled;
    }
    /**
     * Switches all active device used in this room to the given device.
     *
     * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
     *
     * @param kind use `videoinput` for camera track,
     *  `audioinput` for microphone track,
     *  `audiooutput` to set speaker for all incoming audio tracks
     * @param deviceId
     */
    switchActiveDevice(kind, deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (kind === 'audioinput') {
                const tracks = Array
                    .from(this.localParticipant.audioTracks.values())
                    .filter((track) => track.source === Track_1.Track.Source.Microphone);
                yield Promise.all(tracks.map((t) => { var _a; return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceId); }));
                this.options.audioCaptureDefaults.deviceId = deviceId;
            }
            else if (kind === 'videoinput') {
                const tracks = Array
                    .from(this.localParticipant.videoTracks.values())
                    .filter((track) => track.source === Track_1.Track.Source.Camera);
                yield Promise.all(tracks.map((t) => { var _a; return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceId); }));
                this.options.videoCaptureDefaults.deviceId = deviceId;
            }
            else if (kind === 'audiooutput') {
                const elements = [];
                this.participants.forEach((p) => {
                    p.audioTracks.forEach((t) => {
                        if (t.isSubscribed && t.track) {
                            t.track.attachedElements.forEach((e) => {
                                elements.push(e);
                            });
                        }
                    });
                });
                yield Promise.all(elements.map((e) => __awaiter(this, void 0, void 0, function* () {
                    if ('setSinkId' in e) {
                        /* @ts-ignore */
                        yield e.setSinkId(deviceId);
                    }
                })));
            }
        });
    }
    onTrackAdded(mediaTrack, stream, receiver) {
        const parts = utils_2.unpackStreamId(stream.id);
        const participantId = parts[0];
        let trackId = parts[1];
        if (!trackId || trackId === '')
            trackId = mediaTrack.id;
        const participant = this.getOrCreateParticipant(participantId);
        let adaptiveStreamSettings;
        if (this.options.adaptiveStream) {
            if (typeof this.options.adaptiveStream === 'object') {
                adaptiveStreamSettings = this.options.adaptiveStream;
            }
            else {
                adaptiveStreamSettings = {};
            }
        }
        participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);
    }
    handleDisconnect(shouldStopTracks = true) {
        if (this.state === RoomState.Disconnected) {
            return;
        }
        this.participants.forEach((p) => {
            p.tracks.forEach((pub) => {
                p.unpublishTrack(pub.trackSid);
            });
        });
        this.localParticipant.tracks.forEach((pub) => {
            var _a, _b;
            if (pub.track) {
                this.localParticipant.unpublishTrack(pub.track);
            }
            if (shouldStopTracks) {
                (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();
                (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
            }
        });
        this.participants.clear();
        this.activeSpeakers = [];
        if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = undefined;
        }
        if (utils_2.isWeb()) {
            window.removeEventListener('beforeunload', this.onBeforeUnload);
            navigator.mediaDevices.removeEventListener('devicechange', this.handleDeviceChange);
        }
        this.state = RoomState.Disconnected;
        this.emit(events_2.RoomEvent.Disconnected);
        this.emit(events_2.RoomEvent.StateChanged, this.state);
    }
    handleParticipantDisconnected(sid, participant) {
        // remove and send event
        this.participants.delete(sid);
        if (!participant) {
            return;
        }
        participant.tracks.forEach((publication) => {
            participant.unpublishTrack(publication.trackSid);
        });
        this.emit(events_2.RoomEvent.ParticipantDisconnected, participant);
    }
    acquireAudioContext() {
        if (this.audioContext) {
            this.audioContext.close();
        }
        // by using an AudioContext, it reduces lag on audio elements
        // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854
        const ctx = utils_1.getNewAudioContext();
        if (ctx) {
            this.audioContext = ctx;
        }
    }
    createParticipant(id, info) {
        let participant;
        if (info) {
            participant = RemoteParticipant_1.default.fromParticipantInfo(this.engine.client, info);
        }
        else {
            participant = new RemoteParticipant_1.default(this.engine.client, id, '');
        }
        return participant;
    }
    getOrCreateParticipant(id, info) {
        if (this.participants.has(id)) {
            return this.participants.get(id);
        }
        // it's possible for the RTC track to arrive before signaling data
        // when this happens, we'll create the participant and make the track work
        const participant = this.createParticipant(id, info);
        this.participants.set(id, participant);
        // also forward events
        // trackPublished is only fired for tracks added after both local participant
        // and remote participant joined the room
        participant
            .on(events_2.ParticipantEvent.TrackPublished, (trackPublication) => {
            this.emit(events_2.RoomEvent.TrackPublished, trackPublication, participant);
        })
            .on(events_2.ParticipantEvent.TrackSubscribed, (track, publication) => {
            // monitor playback status
            if (track.kind === Track_1.Track.Kind.Audio) {
                track.on(events_2.TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);
                track.on(events_2.TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);
            }
            this.emit(events_2.RoomEvent.TrackSubscribed, track, publication, participant);
        })
            .on(events_2.ParticipantEvent.TrackUnpublished, (publication) => {
            this.emit(events_2.RoomEvent.TrackUnpublished, publication, participant);
        })
            .on(events_2.ParticipantEvent.TrackUnsubscribed, (track, publication) => {
            this.emit(events_2.RoomEvent.TrackUnsubscribed, track, publication, participant);
        })
            .on(events_2.ParticipantEvent.TrackSubscriptionFailed, (sid) => {
            this.emit(events_2.RoomEvent.TrackSubscriptionFailed, sid, participant);
        })
            .on(events_2.ParticipantEvent.TrackMuted, (pub) => {
            this.emit(events_2.RoomEvent.TrackMuted, pub, participant);
        })
            .on(events_2.ParticipantEvent.TrackUnmuted, (pub) => {
            this.emit(events_2.RoomEvent.TrackUnmuted, pub, participant);
        })
            .on(events_2.ParticipantEvent.MetadataChanged, (metadata) => {
            this.emit(events_2.RoomEvent.MetadataChanged, metadata, participant);
        })
            .on(events_2.ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
            this.emit(events_2.RoomEvent.ParticipantMetadataChanged, metadata, participant);
        })
            .on(events_2.ParticipantEvent.ConnectionQualityChanged, (quality) => {
            this.emit(events_2.RoomEvent.ConnectionQualityChanged, quality, participant);
        })
            .on(events_2.ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {
            this.emit(events_2.RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);
        });
        return participant;
    }
    sendSyncState() {
        var _a;
        if (this.engine.subscriber === undefined
            || this.engine.subscriber.pc.localDescription === null) {
            return;
        }
        const previousSdp = this.engine.subscriber.pc.localDescription;
        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,
              in this case, we send unsub tracks, so server add all tracks to this
              subscribe pc and unsub special tracks from it.
           2. autosubscribe off, we send subscribed tracks.
        */
        const sendUnsub = ((_a = this.connOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe) || false;
        const trackSids = new Array();
        this.participants.forEach((participant) => {
            participant.tracks.forEach((track) => {
                if (track.isSubscribed !== sendUnsub) {
                    trackSids.push(track.trackSid);
                }
            });
        });
        this.engine.client.sendSyncState({
            answer: SignalClient_1.toProtoSessionDescription({
                sdp: previousSdp.sdp,
                type: previousSdp.type,
            }),
            subscription: {
                trackSids,
                subscribe: !sendUnsub,
                participantTracks: [],
            },
            publishTracks: this.localParticipant.publishedTracksInfo(),
            dataChannels: this.localParticipant.dataChannelsInfo(),
        });
    }
    /**
     * After resuming, we'll need to notify the server of the current
     * subscription settings.
     */
    updateSubscriptions() {
        for (const p of this.participants.values()) {
            for (const pub of p.videoTracks.values()) {
                if (pub.isSubscribed && pub instanceof RemoteTrackPublication_1.default) {
                    pub.emitTrackUpdate();
                }
            }
        }
    }
    // /** @internal */
    emit(event, ...args) {
        logger_1.default.debug('room event', event, ...args);
        return super.emit(event, ...args);
    }
}
exports.default = Room;
//# sourceMappingURL=Room.js.map