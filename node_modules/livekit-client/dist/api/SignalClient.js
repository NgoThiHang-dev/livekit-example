"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toProtoSessionDescription = exports.SignalClient = void 0;
const logger_1 = __importDefault(require("../logger"));
const livekit_rtc_1 = require("../proto/livekit_rtc");
const errors_1 = require("../room/errors");
const utils_1 = require("../room/utils");
const RequestQueue_1 = __importDefault(require("./RequestQueue"));
if (utils_1.isWeb()) {
    Promise.resolve().then(() => __importStar(require('webrtc-adapter')));
}
const passThroughQueueSignals = [
    'syncState',
    'trickle',
    'offer',
    'answer',
    'simulate',
    'leave',
];
function canPassThroughQueue(req) {
    const canPass = Object.keys(req)
        .find((key) => passThroughQueueSignals.includes(key)) !== undefined;
    logger_1.default.trace('request allowed to bypass queue:', canPass, req);
    return canPass;
}
/** @internal */
class SignalClient {
    constructor(useJSON = false) {
        this.isConnected = false;
        this.isReconnecting = false;
        this.useJSON = useJSON;
        this.requestQueue = new RequestQueue_1.default();
    }
    join(url, token, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            // during a full reconnect, we'd want to start the sequence even if currently
            // connected
            this.isConnected = false;
            const res = yield this.connect(url, token, {
                autoSubscribe: opts === null || opts === void 0 ? void 0 : opts.autoSubscribe,
                publishOnly: opts === null || opts === void 0 ? void 0 : opts.publishOnly,
            });
            return res;
        });
    }
    reconnect(url, token) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isReconnecting = true;
            yield this.connect(url, token, {
                reconnect: true,
            });
        });
    }
    connect(url, token, opts) {
        if (url.startsWith('http')) {
            url = url.replace('http', 'ws');
        }
        // strip trailing slash
        url = url.replace(/\/$/, '');
        url += '/rtc';
        const clientInfo = utils_1.getClientInfo();
        const params = createConnectionParams(token, clientInfo, opts);
        return new Promise((resolve, reject) => {
            logger_1.default.debug('connecting to', url + params);
            this.ws = undefined;
            const ws = new WebSocket(url + params);
            ws.binaryType = 'arraybuffer';
            ws.onerror = (ev) => __awaiter(this, void 0, void 0, function* () {
                if (!this.ws) {
                    try {
                        const resp = yield fetch(`http${url.substring(2)}/validate${params}`);
                        if (!resp.ok) {
                            const msg = yield resp.text();
                            reject(new errors_1.ConnectionError(msg));
                        }
                        else {
                            reject(new errors_1.ConnectionError('Internal error'));
                        }
                    }
                    catch (e) {
                        reject(new errors_1.ConnectionError('server was not reachable'));
                    }
                    return;
                }
                // other errors, handle
                this.handleWSError(ev);
            });
            ws.onopen = () => {
                this.ws = ws;
                if (opts.reconnect) {
                    // upon reconnection, there will not be additional handshake
                    this.isConnected = true;
                    resolve();
                }
            };
            ws.onmessage = (ev) => __awaiter(this, void 0, void 0, function* () {
                // not considered connected until JoinResponse is received
                let msg;
                if (typeof ev.data === 'string') {
                    const json = JSON.parse(ev.data);
                    msg = livekit_rtc_1.SignalResponse.fromJSON(json);
                }
                else if (ev.data instanceof ArrayBuffer) {
                    msg = livekit_rtc_1.SignalResponse.decode(new Uint8Array(ev.data));
                }
                else {
                    logger_1.default.error('could not decode websocket message', typeof ev.data);
                    return;
                }
                if (!this.isConnected) {
                    // handle join message only
                    if (msg.join) {
                        this.isConnected = true;
                        resolve(msg.join);
                    }
                    else {
                        reject(new errors_1.ConnectionError('did not receive join response'));
                    }
                    return;
                }
                if (this.signalLatency) {
                    yield utils_1.sleep(this.signalLatency);
                }
                this.handleSignalResponse(msg);
            });
            ws.onclose = (ev) => {
                if (!this.isConnected || this.ws !== ws)
                    return;
                logger_1.default.debug('websocket connection closed', ev.reason);
                this.isConnected = false;
                if (this.onClose)
                    this.onClose(ev.reason);
                if (this.ws === ws) {
                    this.ws = undefined;
                }
            };
        });
    }
    close() {
        var _a;
        this.isConnected = false;
        if (this.ws)
            this.ws.onclose = null;
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();
        this.ws = undefined;
    }
    // initial offer after joining
    sendOffer(offer) {
        logger_1.default.debug('sending offer', offer);
        this.sendRequest({
            offer: toProtoSessionDescription(offer),
        });
    }
    // answer a server-initiated offer
    sendAnswer(answer) {
        logger_1.default.debug('sending answer');
        this.sendRequest({
            answer: toProtoSessionDescription(answer),
        });
    }
    sendIceCandidate(candidate, target) {
        logger_1.default.trace('sending ice candidate', candidate);
        this.sendRequest({
            trickle: {
                candidateInit: JSON.stringify(candidate),
                target,
            },
        });
    }
    sendMuteTrack(trackSid, muted) {
        this.sendRequest({
            mute: {
                sid: trackSid,
                muted,
            },
        });
    }
    sendAddTrack(req) {
        this.sendRequest({
            addTrack: livekit_rtc_1.AddTrackRequest.fromPartial(req),
        });
    }
    sendUpdateTrackSettings(settings) {
        this.sendRequest({ trackSetting: settings });
    }
    sendUpdateSubscription(sub) {
        this.sendRequest({ subscription: sub });
    }
    sendSyncState(sync) {
        this.sendRequest({ syncState: sync });
    }
    sendUpdateVideoLayers(trackSid, layers) {
        this.sendRequest({
            updateLayers: {
                trackSid,
                layers,
            },
        });
    }
    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
        this.sendRequest({
            subscriptionPermission: {
                allParticipants,
                trackPermissions,
            },
        });
    }
    sendSimulateScenario(scenario) {
        this.sendRequest({
            simulate: scenario,
        });
    }
    sendLeave() {
        this.sendRequest(livekit_rtc_1.SignalRequest.fromPartial({ leave: {} }));
    }
    sendRequest(req, fromQueue = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // capture all requests while reconnecting and put them in a queue.
            // keep order by queueing up new events as long as the queue is not empty
            // unless the request originates from the queue, then don't enqueue again
            const canQueue = !fromQueue && !canPassThroughQueue(req);
            if (canQueue && (this.isReconnecting || (!this.requestQueue.isEmpty()))) {
                this.requestQueue.enqueue(() => this.sendRequest(req, true));
                return;
            }
            if (this.signalLatency) {
                yield utils_1.sleep(this.signalLatency);
            }
            if (!this.ws) {
                logger_1.default.error('cannot send signal request before connected');
                return;
            }
            try {
                if (this.useJSON) {
                    this.ws.send(JSON.stringify(livekit_rtc_1.SignalRequest.toJSON(req)));
                }
                else {
                    this.ws.send(livekit_rtc_1.SignalRequest.encode(req).finish());
                }
            }
            catch (e) {
                logger_1.default.error('error sending signal message', e);
            }
        });
    }
    handleSignalResponse(msg) {
        if (msg.answer) {
            const sd = fromProtoSessionDescription(msg.answer);
            if (this.onAnswer) {
                this.onAnswer(sd);
            }
        }
        else if (msg.offer) {
            const sd = fromProtoSessionDescription(msg.offer);
            if (this.onOffer) {
                this.onOffer(sd);
            }
        }
        else if (msg.trickle) {
            const candidate = JSON.parse(msg.trickle.candidateInit);
            if (this.onTrickle) {
                this.onTrickle(candidate, msg.trickle.target);
            }
        }
        else if (msg.update) {
            if (this.onParticipantUpdate) {
                this.onParticipantUpdate(msg.update.participants);
            }
        }
        else if (msg.trackPublished) {
            if (this.onLocalTrackPublished) {
                this.onLocalTrackPublished(msg.trackPublished);
            }
        }
        else if (msg.speakersChanged) {
            if (this.onSpeakersChanged) {
                this.onSpeakersChanged(msg.speakersChanged.speakers);
            }
        }
        else if (msg.leave) {
            if (this.onLeave) {
                this.onLeave(msg.leave);
            }
        }
        else if (msg.mute) {
            if (this.onRemoteMuteChanged) {
                this.onRemoteMuteChanged(msg.mute.sid, msg.mute.muted);
            }
        }
        else if (msg.roomUpdate) {
            if (this.onRoomUpdate) {
                this.onRoomUpdate(msg.roomUpdate.room);
            }
        }
        else if (msg.connectionQuality) {
            if (this.onConnectionQuality) {
                this.onConnectionQuality(msg.connectionQuality);
            }
        }
        else if (msg.streamStateUpdate) {
            if (this.onStreamStateUpdate) {
                this.onStreamStateUpdate(msg.streamStateUpdate);
            }
        }
        else if (msg.subscribedQualityUpdate) {
            if (this.onSubscribedQualityUpdate) {
                this.onSubscribedQualityUpdate(msg.subscribedQualityUpdate);
            }
        }
        else if (msg.subscriptionPermissionUpdate) {
            if (this.onSubscriptionPermissionUpdate) {
                this.onSubscriptionPermissionUpdate(msg.subscriptionPermissionUpdate);
            }
        }
        else if (msg.refreshToken) {
            if (this.onTokenRefresh) {
                this.onTokenRefresh(msg.refreshToken);
            }
        }
        else if (msg.trackUnpublished) {
            if (this.onLocalTrackUnpublished) {
                this.onLocalTrackUnpublished(msg.trackUnpublished);
            }
        }
        else {
            logger_1.default.debug('unsupported message', msg);
        }
    }
    setReconnected() {
        this.isReconnecting = false;
        this.requestQueue.run();
    }
    handleWSError(ev) {
        logger_1.default.error('websocket error', ev);
    }
}
exports.SignalClient = SignalClient;
function fromProtoSessionDescription(sd) {
    const rsd = {
        type: 'offer',
        sdp: sd.sdp,
    };
    switch (sd.type) {
        case 'answer':
        case 'offer':
        case 'pranswer':
        case 'rollback':
            rsd.type = sd.type;
            break;
        default:
            break;
    }
    return rsd;
}
function toProtoSessionDescription(rsd) {
    const sd = {
        sdp: rsd.sdp,
        type: rsd.type,
    };
    return sd;
}
exports.toProtoSessionDescription = toProtoSessionDescription;
function createConnectionParams(token, info, opts) {
    const params = new URLSearchParams();
    params.set('access_token', token);
    // opts
    if (opts === null || opts === void 0 ? void 0 : opts.reconnect) {
        params.set('reconnect', '1');
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.autoSubscribe) !== undefined) {
        params.set('auto_subscribe', opts.autoSubscribe ? '1' : '0');
    }
    // ClientInfo
    params.set('sdk', 'js');
    params.set('version', info.version);
    params.set('protocol', info.protocol.toString());
    if (info.deviceModel) {
        params.set('device_model', info.deviceModel);
    }
    if (info.os) {
        params.set('os', info.os);
    }
    if (info.osVersion) {
        params.set('os_version', info.osVersion);
    }
    if (info.browser) {
        params.set('browser', info.browser);
    }
    if (info.browserVersion) {
        params.set('browser_version', info.browserVersion);
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.publishOnly) !== undefined) {
        params.set('publish', opts.publishOnly);
    }
    return `?${params.toString()}`;
}
//# sourceMappingURL=SignalClient.js.map